<!DOCTYPE html>
<html>
<head>
<title>protocol-spec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<base href='file:\\\E:\Workspace\fabric\docs\'/>
</head>
<body>
<h1>Protocol Specification</h1>
<h2>Preface</h2>
<p>This document is the protocol specification for a permissioned blockchain implementation for industry use-cases. It is not intended to be a complete explanation of the implementation, but rather a description of the interfaces and relationships between components in the system and the application.</p>
<h3>Intended Audience</h3>
<p>The intended audience for this specification includes the following groups:</p>
<ul>
<li>Blockchain vendors who want to implement blockchain systems that conform to this specification</li>
<li>Tool developers who want to extend the capabilities of the fabric</li>
<li>Application developers who want to leverage blockchain technologies to enrich their applications</li>
</ul>
<hr>
<h2>Table of Contents</h2>
<h4><a href="#1-introduction_1">1. Introduction</a></h4>
<ul>
<li><a href="#11-what-is-the-fabric">1.1 What is the fabric?</a></li>
<li><a href="#12-why-the-fabric">1.2 Why the fabric?</a></li>
<li><a href="#13-terminology">1.3 Terminology</a></li>
</ul>
<h4><a href="#2-fabric_1">2. Fabric</a></h4>
<ul>
<li><a href="#21-architecture">2.1 Architecture</a></li>
<li><a href="#211-membership-services">2.1.1 Membership Services</a></li>
<li><a href="#212-blockchain-services">2.1.2 Blockchain Services</a></li>
<li><a href="#213-chaincode-services">2.1.3 Chaincode Services</a></li>
<li><a href="#214-events">2.1.4 Events</a></li>
<li><a href="#215-application-programming-interface-api">2.1.5 Application Programming Interface (API)</a></li>
<li><a href="#216-command-line-interface-cli">2.1.6 Command Line Interface (CLI)</a></li>
<li><a href="#22-topology">2.2 Topology</a></li>
<li><a href="#221-single-validating-peer">2.2.1 Single Validating Peer</a></li>
<li><a href="#222-multiple-validating-peers">2.2.2 Multiple Validating Peers</a></li>
<li><a href="#223-multichain">2.2.3 Multichain</a></li>
</ul>
<h4><a href="#3-protocol_1">3. Protocol</a></h4>
<ul>
<li><a href="#31-message">3.1 Message</a></li>
<li><a href="#311-discovery-messages">3.1.1 Discovery Messages</a></li>
<li><a href="#312-transaction-messages">3.1.2 Transaction Messages</a></li>
<li><a href="#3121-transaction-data-structure">3.1.2.1 Transaction Data Structure</a></li>
<li><a href="#3122-transaction-specification">3.1.2.2 Transaction Specification</a></li>
<li><a href="#3123-deploy-transaction">3.1.2.3 Deploy Transaction</a></li>
<li><a href="#3124-invoke-transaction">3.1.2.4 Invoke Transaction</a></li>
<li><a href="#3125-query-transaction">3.1.2.5 Query Transaction</a></li>
<li><a href="#313-synchronization-messages">3.1.3 Synchronization Messages</a></li>
<li><a href="#314-consensus-messages">3.1.4 Consensus Messages</a></li>
<li><a href="#32-ledger">3.2 Ledger</a></li>
<li><a href="#321-blockchain">3.2.1 Blockchain</a></li>
<li><a href="#3211-block">3.2.1.1 Block</a></li>
<li><a href="#3212-block-hashing">3.2.1.2 Block Hashing</a></li>
<li><a href="#3213-nonhashdata">3.2.1.3 NonHashData</a></li>
<li><a href="#3214-transaction-execution">3.2.1.4 Transaction Execution</a></li>
<li><a href="#322-world-state">3.2.2 World State</a></li>
<li><a href="#3221-hashing-the-world-state">3.2.2.1 Hashing the world state</a></li>
<li><a href="#32211-buckettree">3.2.2.1.1 Bucket-tree</a></li>
<li><a href="#33-chaincode">3.3 Chaincode</a></li>
<li><a href="#331-virtual-machine-instantiation">3.3.1 Virtual Machine Instantiation</a></li>
<li><a href="#332-chaincode-protocol">3.3.2 Chaincode Protocol</a></li>
<li><a href="#3321-chaincode-deploy">3.3.2.1 Chaincode Deploy</a></li>
<li><a href="#3322-chaincode-invoke">3.3.2.2 Chaincode Invoke</a></li>
<li><a href="#3323-chaincode-query">3.3.2.3 Chaincode Query</a></li>
<li><a href="#3324-chaincode-state">3.3.2.4 Chaincode State</a></li>
<li><a href="#34-pluggable-consensus-framework">3.4 Pluggable Consensus Framework</a></li>
<li><a href="#341-consenter-interface">3.4.1 Consenter interface</a></li>
<li><a href="#342-cpi-interface">3.4.2 CPI interface</a></li>
<li><a href="#343-inquirer-interface">3.4.3 Inquirer interface</a></li>
<li><a href="#344-communicator-interface">3.4.4 Communicator interface</a></li>
<li><a href="#345-securityutils-interface">3.4.5 SecurityUtils interface</a></li>
<li><a href="#346-ledgerstack-interface">3.4.6 LedgerStack interface</a></li>
<li><a href="#347-executor-interface">3.4.7 Executor interface</a></li>
<li><a href="#3471-beginning-a-transaction-batch">3.4.7.1 Beginning a transaction batch</a></li>
<li><a href="#3472-executing-transactions">3.4.7.2 Executing transactions</a></li>
<li><a href="#3473-committing-and-rollingback-transactions">3.4.7.3 Committing and rolling-back transactions</a></li>
<li><a href="#348-ledger-interface">3.4.8 Ledger interface</a></li>
<li><a href="#3481-readonlyledger-interface">3.4.8.1 ReadOnlyLedger interface</a></li>
<li><a href="#3482-utilledger-interface">3.4.8.2 UtilLedger interface</a></li>
<li><a href="#3483-writableledger-interface">3.4.8.3 WritableLedger interface</a></li>
<li><a href="#349-remoteledgers-interface">3.4.9 RemoteLedgers interface</a></li>
<li><a href="#3410-controller-package">3.4.10 controller package</a></li>
<li><a href="#34101-controllernewconsenter">3.4.10.1 controller.NewConsenter</a></li>
<li><a href="#3411-helper-package">3.4.11 helper package</a></li>
<li><a href="#34111-highlevel-overview">3.4.11.1 High-level overview</a></li>
<li><a href="#34112-helperconsensushandler">3.4.11.2 helper.ConsensusHandler</a></li>
<li><a href="#34113-helpernewconsensushandler">3.4.11.3 helper.NewConsensusHandler</a></li>
<li><a href="#34114-helperhelper">3.4.11.4 helper.Helper</a></li>
<li><a href="#34115-helpernewhelper">3.4.11.5 helper.NewHelper</a></li>
<li><a href="#34116-helperhandlemessage">3.4.11.6 helper.HandleMessage</a></li>
<li><a href="#35-events">3.5 Events</a></li>
<li><a href="#351-event-stream">3.5.1 Event Stream</a></li>
<li><a href="#3511-event-producer">3.5.1.1 Event Producer</a></li>
<li><a href="#3512-event-consumer">3.5.1.2 Event Consumer</a></li>
<li><a href="#352-event-adapters">3.5.2 Event Adapters</a></li>
<li><a href="#353-event-structure">3.5.3 Event Structure</a></li>
</ul>
<h4><a href="#4-security_1">4. Security</a></h4>
<ul>
<li><a href="#41-business-security-requirements">4.1 Business security requirements</a></li>
<li><a href="#42-user-privacy-through-membership-services">4.2 User Privacy through Membership Services</a></li>
<li><a href="#421-userclient-enrollment-process">4.2.1 User/Client Enrollment Process</a></li>
<li><a href="#422-expiration-and-revocation-of-certificates">4.2.2 Expiration and revocation of certificates</a></li>
<li><a href="#43-transaction-security-offerings-at-the-infrastructure-level">4.3 Transaction security offerings at the infrastructure level</a></li>
<li><a href="#431-security-lifecycle-of-transactions">4.3.1 Security Lifecycle of Transactions</a></li>
<li><a href="#432-transaction-confidentiality">4.3.2 Transaction confidentiality</a></li>
<li><a href="#4321-confidentiality-against-users">4.3.2.1 Confidentiality against users</a></li>
<li><a href="#4322-confidentiality-against-validators">4.3.2.2 Confidentiality against validators</a></li>
<li><a href="#433-replay-attack-resistance">4.3.3 Replay attack resistance</a></li>
<li><a href="#44-access-control-features-on-the-application">4.4 Access control features on the application</a></li>
<li><a href="#441-invocation-access-control">4.4.1 Invocation access control</a></li>
<li><a href="#442-read-access-control">4.4.2 Read access control</a></li>
<li><a href="#45-online-wallet-service">4.5 Online wallet service</a></li>
<li><a href="#46-network-security-tls">4.6 Network security (TLS)</a></li>
<li><a href="#47-restrictions-in-the-current-release">4.7 Restrictions in the current release</a></li>
<li><a href="#471-simplified-client">4.7.1 Simplified client</a></li>
<li><a href="#472-simplified-transaction-confidentiality">4.7.2 Simplified transaction confidentiality</a></li>
</ul>
<h4><a href="#5-byzantine-consensus_1">5. Byzantine Consensus</a></h4>
<ul>
<li><a href="#51-overview">5.1 Overview</a></li>
<li><a href="#52-core-pbft-functions">5.2 Core PBFT Functions</a></li>
<li><a href="#521-newpbftcore">5.2.1 newPbftCore</a></li>
</ul>
<h4><a href="#6-application-programming-interface_1">6. Application Programming Interface</a></h4>
<ul>
<li><a href="#61-rest-service">6.1 REST Service</a></li>
<li><a href="#62-rest-api">6.2 REST API</a></li>
<li><a href="#621-rest-endpoints">6.2.1 REST Endpoints</a></li>
<li><a href="#6211-block-api">6.2.1.1 Block API</a></li>
<li><a href="#6212-blockchain-api">6.2.1.2 Blockchain API</a></li>
<li><a href="#6213-chaincode-api">6.2.1.3 Chaincode API</a></li>
<li><a href="#6214-network-api">6.2.1.4 Network API</a></li>
<li><a href="#6215-registrar-api-member-services">6.2.1.5 Registrar API (member services)</a></li>
<li><a href="#6216-transactions-api">6.2.1.6 Transactions API</a></li>
<li><a href="#63-cli">6.3 CLI</a></li>
<li><a href="#631-cli-commands">6.3.1 CLI Commands</a></li>
<li><a href="#6311-node-start">6.3.1.1 node start</a></li>
<li><a href="#6312-network-login">6.3.1.2 network login</a></li>
<li><a href="#6313-chaincode-deploy">6.3.1.3 chaincode deploy</a></li>
<li><a href="#6314-chaincode-invoke">6.3.1.4 chaincode invoke</a></li>
<li><a href="#6315-chaincode-query">6.3.1.5 chaincode query</a></li>
</ul>
<h4><a href="#7-application-model_1">7. Application Model</a></h4>
<ul>
<li><a href="#71-composition-of-an-application">7.1 Composition of an Application</a></li>
<li><a href="#72-sample-application">7.2 Sample Application</a></li>
</ul>
<h4><a href="#8-future-directions_1">8. Future Directions</a></h4>
<ul>
<li><a href="#81-enterprise-integration">8.1 Enterprise Integration</a></li>
<li><a href="#82-performance-and-scalability">8.2 Performance and Scalability</a></li>
<li><a href="#83-additional-consensus-plugins">8.3 Additional Consensus Plugins</a></li>
<li><a href="#84-additional-languages">8.4 Additional Languages</a></li>
</ul>
<h4><a href="#91-authors">9.1 Authors</a></h4>
<h4><a href="#92-reviewers">9.2 Reviewers</a></h4>
<h4><a href="#93-acknowledgements">9.3 Acknowledgements</a></h4>
<h4><a href="#10-references_1">10. References</a></h4>
<hr>
<h2>1. Introduction</h2>
<p>This document specifies the principles, architecture, and protocol of a blockchain implementation suitable for industrial use-cases.</p>
<h3>1.1 What is the fabric?</h3>
<p>The fabric is a ledger of digital events, called transactions, shared among  different participants, each having a stake in the system. The ledger can only be updated by consensus of the participants, and, once recorded, information can never be altered. Each recorded event is cryptographically verifiable with proof of agreement from the participants.</p>
<p>Transactions are secured, private, and confidential. Each participant registers with proof of identity to the network membership services to gain access to the system. Transactions are issued with derived certificates unlinkable to the individual participant, offering a complete anonymity on the network. Transaction content is encrypted with sophisticated key derivation functions to ensure only intended participants may see the content, protecting the confidentiality of the business transactions.</p>
<p>The ledger allows compliance with regulations as ledger entries are auditable in whole or in part. In collaboration with participants, auditors may obtain time-based certificates to allow viewing the ledger and linking transactions to provide an accurate assessment of the operations.</p>
<p>The fabric is an implementation of blockchain technology, where Bitcoin could be a simple application built on the fabric. It is a modular architecture allowing components to be plug-and-play by implementing this protocol specification. It features powerful container technology to host any main stream language for smart contracts development. Leveraging familiar and proven technologies is the motto of the fabric architecture.</p>
<h3>1.2 Why the fabric?</h3>
<p>Early blockchain technology serves a set of purposes but is often not well-suited for the needs of specific industries. To meet the demands of modern markets, the fabric is based on an industry-focused design that addresses the multiple and varied requirements of specific industry use cases, extending the learning of the pioneers in this field while also addressing issues such as scalability. The fabric provides a new approach to enable permissioned networks, privacy, and confidentially on multiple blockchain networks.</p>
<h3>1.3 Terminology</h3>
<p>The following terminology is defined within the limited scope of this specification to help readers understand clearly and precisely the concepts described here.</p>
<p><strong>Transaction</strong> is a request to the blockchain to execute a function on the ledger. The function is implemented by a <strong>chaincode</strong>.</p>
<p><strong>Transactor</strong> is an entity that issues transactions such as a client application.</p>
<p><strong>Ledger</strong> is a sequence of cryptographically linked blocks, containing transactions and current <strong>world state</strong>.</p>
<p><strong>World State</strong> is the collection of variables containing the results of executed transactions.</p>
<p><strong>Chaincode</strong> is an application-level code (a.k.a. <a href="https://en.wikipedia.org/wiki/Smart_contract">smart contract</a>) stored on the ledger as a part of a transaction. Chaincode runs transactions that may modify the world state.</p>
<p><strong>Validating Peer</strong> is a computer node on the network responsible for running consensus, validating transactions, and maintaining the ledger.</p>
<p><strong>Non-validating Peer</strong> is a computer node on the network which functions as a proxy connecting transactors to the neighboring validating peers. A non-validating peer doesn't execute transactions but does verify them. It also hosts the event stream server and the REST service.</p>
<p><strong>Permissioned Ledger</strong> is a blockchain network where each entity or node is required to be a member of the network. Anonymous nodes are not allowed to connect.</p>
<p><strong>Privacy</strong> is required by the chain transactors to conceal their identities on the network. While members of the network may examine the transactions, the transactions can't be linked to the transactor without special privilege.</p>
<p><strong>Confidentiality</strong> is the ability to render the transaction content inaccessible to anyone other than the stakeholders of the transaction.</p>
<p><strong>Auditability</strong> of the blockchain is required, as business usage of blockchain needs to comply with regulations to make it easy for regulators to investigate transaction records.</p>
<h2>2. Fabric</h2>
<p>The fabric is made up of the core components described in the subsections below.</p>
<h3>2.1 Architecture</h3>
<p>The reference architecture is aligned in 3 categories: Membership, Blockchain, and Chaincode services. These categories are logical structures, not a physical depiction of partitioning of components into separate processes, address spaces or (virtual) machines.</p>
<p><a href="images/refarch.png" target="_blank"><img src="images/refarch.png" alt="Reference architecture" style="max-width:100%;"></a></p>
<h4>2.1.1 Membership Services</h4>
<p>Membership provides services for managing identity, privacy, confidentiality and auditability on the network. In a non-permissioned blockchain, participation does not require authorization and all nodes can equally submit transactions and/or attempt to accumulate them into acceptable blocks, i.e. there are no distinctions of roles. Membership services combine elements of Public Key Infrastructure (PKI) and decentralization/consensus to transform a non-permissioned blockchain into a permissioned blockchain. In the latter, entities register in order to acquire long-term identity credentials (enrollment certificates), and may be distinguished according to entity type. In the case of users, such credentials enable the Transaction Certificate Authority (TCA) to issue pseudonymous credentials. Such credentials, i.e., transaction certificates, are used to authorize submitted transactions. Transaction certificates persist on the blockchain, and enable authorized auditors to cluster otherwise unlinkable transactions.</p>
<h4>2.1.2 Blockchain Services</h4>
<p>Blockchain services manage the distributed ledger through a peer-to-peer protocol, built on HTTP/2. The data structures are highly optimized to provide the most efficient hash algorithm for maintaining the world state replication. Different consensus (PBFT, Raft, PoW, PoS) may be plugged in and configured per deployment.</p>
<h4>2.1.3 Chaincode Services</h4>
<p>Chaincode services provides a secured and lightweight way to sandbox the chaincode execution on the validating nodes. The environment is a “locked down” and secured container along with a set of signed base images containing secure OS and chaincode language, runtime and SDK layers for Go, Java, and Node.js. Other languages can be enabled if required.</p>
<h4>2.1.4 Events</h4>
<p>Validating peers and chaincodes can emit events on the network that applications may listen for and take actions on. There is a set of pre-defined events, and chaincodes can generate custom events. Events are consumed by 1 or more event adapters. Adapters may further deliver events using other vehicles such as Web hooks or Kafka.</p>
<h4>2.1.5 Application Programming Interface (API)</h4>
<p>The primary interface to the fabric is a REST API and its variations over Swagger 2.0. The API allows applications to register users, query the blockchain, and to issue transactions. There is a set of APIs specifically for chaincode to interact with the stack to execute transactions and query transaction results.</p>
<h4>2.1.6 Command Line Interface (CLI)</h4>
<p>CLI includes a subset of the REST API to enable developers to quickly test chaincodes or query for status of transactions. CLI is implemented in Golang and operable on multiple OS platforms.</p>
<h3>2.2 Topology</h3>
<p>A deployment of the fabric can consist of a membership service, many validating peers, non-validating peers, and 1 or more applications. All of these components make up a chain. There can be multiple chains; each one having its own operating parameters and security requirements.</p>
<h4>2.2.1 Single Validating Peer</h4>
<p>Functionally, a non-validating peer is a subset of a validating peer; that is, every capability on a non-validating peer may be enabled on a validating peer, so the simplest network may consist of a single validating peer node. This configuration is most appropriate for a development environment, where a single validating peer may be started up during the edit-compile-debug cycle.</p>
<p><a href="images/top-single-peer.png" target="_blank"><img src="images/top-single-peer.png" alt="Single Validating Peer" style="max-width:100%;"></a></p>
<p>A single validating peer doesn't require consensus, and by default uses the <code>noops</code> plugin, which executes transactions as they arrive. This gives the developer an immediate feedback during development.</p>
<h4>2.2.2 Multiple Validating Peers</h4>
<p>Production or test networks should be made up of multiple validating and non-validating peers as necessary. Non-validating peers can take workload off the validating peers, such as handling API requests and processing events.</p>
<p><a href="images/top-multi-peer.png" target="_blank"><img src="images/top-multi-peer.png" alt="Multiple Validating Peers" style="max-width:100%;"></a></p>
<p>The validating peers form a mesh-network (every validating peer connects to every other validating peer) to disseminate information. A non-validating peer connects to a neighboring validating peer that it is allowed to connect to. Non-validating peers are optional since applications may communicate directly with validating peers.</p>
<h4>2.2.3 Multichain</h4>
<p>Each network of validating and non-validating peers makes up a chain. Many chains may be created to address different needs, similar to having multiple Web sites, each serving a different purpose.</p>
<h2>3. Protocol</h2>
<p>The fabric's peer-to-peer communication is built on <a href="http://www.grpc.io/docs/">gRPC</a>, which allows bi-directional stream-based messaging. It uses <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> to serialize data structures for data transfer between peers. Protocol buffers are a language-neutral, platform-neutral and extensible mechanism for serializing structured data. Data structures, messages, and services are described using <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 language</a> notation.</p>
<h3>3.1 Message</h3>
<p>Messages passed between nodes are encapsulated by <code>Message</code> proto structure, which consists of 4 types: Discovery, Transaction, Synchronization, and Consensus. Each type may define more subtypes embedded in the <code>payload</code>.</p>
<pre><code>message Message {
   enum Type {
        UNDEFINED = 0;

        DISC_HELLO = 1;
        DISC_DISCONNECT = 2;
        DISC_GET_PEERS = 3;
        DISC_PEERS = 4;
        DISC_NEWMSG = 5;

        CHAIN_STATUS = 6;
        CHAIN_TRANSACTION = 7;
        CHAIN_GET_TRANSACTIONS = 8;
        CHAIN_QUERY = 9;

        SYNC_GET_BLOCKS = 11;
        SYNC_BLOCKS = 12;
        SYNC_BLOCK_ADDED = 13;

        SYNC_STATE_GET_SNAPSHOT = 14;
        SYNC_STATE_SNAPSHOT = 15;
        SYNC_STATE_GET_DELTAS = 16;
        SYNC_STATE_DELTAS = 17;

        RESPONSE = 20;
        CONSENSUS = 21;
    }
    Type type = 1;
    bytes payload = 2;
    google.protobuf.Timestamp timestamp = 3;
}
</code></pre>
<p>The <code>payload</code> is an opaque byte array containing other objects such as <code>Transaction</code> or <code>Response</code> depending on the type of the message. For example, if the <code>type</code> is <code>CHAIN_TRANSACTION</code>, the <code>payload</code> is a <code>Transaction</code> object.</p>
<h4>3.1.1 Discovery Messages</h4>
<p>Upon start up, a peer runs discovery protocol if <code>CORE_PEER_DISCOVERY_ROOTNODE</code> is specified. <code>CORE_PEER_DISCOVERY_ROOTNODE</code> is the IP address of another peer on the network (any peer) that serves as the starting point for discovering all the peers on the network. The protocol sequence begins with <code>DISC_HELLO</code>, whose <code>payload</code> is a <code>HelloMessage</code> object, containing its endpoint:</p>
<pre><code>message HelloMessage {
  PeerEndpoint peerEndpoint = 1;
  uint64 blockNumber = 2;
}
message PeerEndpoint {
    PeerID ID = 1;
    string address = 2;
    enum Type {
      UNDEFINED = 0;
      VALIDATOR = 1;
      NON_VALIDATOR = 2;
    }
    Type type = 3;
    bytes pkiID = 4;
}

message PeerID {
    string name = 1;
}
</code></pre>
<p><strong>Definition of fields:</strong></p>
<ul>
<li><code>PeerID</code> is any name given to the peer at start up or defined in the config file</li>
<li><code>PeerEndpoint</code> describes the endpoint and whether it's a validating or a non-validating peer</li>
<li><code>pkiID</code> is the cryptographic ID of the peer</li>
<li><code>address</code> is host or IP address and port of the peer in the format <code>ip:port</code></li>
<li><code>blockNumber</code> is the height of the blockchain the peer currently has</li>
</ul>
<p>If the block height received upon <code>DISC_HELLO</code> is higher than the current block height of the peer, it immediately initiates the synchronization protocol to catch up with the network.</p>
<p>After <code>DISC_HELLO</code>, peer sends <code>DISC_GET_PEERS</code> periodically to discover any additional peers joining the network. In response to <code>DISC_GET_PEERS</code>, a peer sends <code>DISC_PEERS</code> with <code>payload</code> containing an array of <code>PeerEndpoint</code>. Other discovery message types are not used at this point.</p>
<h4>3.1.2 Transaction Messages</h4>
<p>There are 3 types of transactions: Deploy, Invoke and Query. A deploy transaction installs the specified chaincode on the chain, while invoke and query transactions call a function of a deployed chaincode. Another type in consideration is Create transaction, where a deployed chaincode may be instantiated on the chain and is addressable. This type has not been implemented as of this writing.</p>
<h5>3.1.2.1 Transaction Data Structure</h5>
<p>Messages with type <code>CHAIN_TRANSACTION</code> or <code>CHAIN_QUERY</code> carry a <code>Transaction</code> object in the <code>payload</code>:</p>
<pre><code>message Transaction {
    enum Type {
        UNDEFINED = 0;
        CHAINCODE_DEPLOY = 1;
        CHAINCODE_INVOKE = 2;
        CHAINCODE_QUERY = 3;
        CHAINCODE_TERMINATE = 4;
    }
    Type type = 1;
    string uuid = 5;
    bytes chaincodeID = 2;
    bytes payloadHash = 3;

    ConfidentialityLevel confidentialityLevel = 7;
    bytes nonce = 8;
    bytes cert = 9;
    bytes signature = 10;

    bytes metadata = 4;
    google.protobuf.Timestamp timestamp = 6;
}

message TransactionPayload {
	bytes payload = 1;
}

enum ConfidentialityLevel {
    PUBLIC = 0;
    CONFIDENTIAL = 1;
}

</code></pre>
<p><strong>Definition of fields:</strong></p>
<ul>
<li><code>type</code> - The type of the transaction, which is 1 of the following:
<ul>
<li><code>UNDEFINED</code> - Reserved for future use.</li>
<li><code>CHAINCODE_DEPLOY</code> - Represents the deployment of a new chaincode.
<ul>
<li><code>CHAINCODE_INVOKE</code> - Represents a chaincode function execution that may read and modify the world state.</li>
<li><code>CHAINCODE_QUERY</code> - Represents a chaincode function execution that may only read the world state.</li>
<li><code>CHAINCODE_TERMINATE</code> - Marks a chaincode as inactive so that future functions of the chaincode can no longer be invoked.</li>
</ul>
</li>
</ul>
</li>
<li><code>chaincodeID</code> - The ID of a chaincode which is a hash of the chaincode source, path to the source code, constructor function, and parameters.</li>
<li><code>payloadHash</code> - Bytes defining the hash of <code>TransactionPayload.payload</code>.</li>
<li><code>metadata</code> - Bytes defining any associated transaction metadata that the application may use.</li>
<li><code>uuid</code> - A unique ID for the transaction.</li>
<li><code>timestamp</code> - A timestamp of when the transaction request was received by the peer.</li>
<li><code>confidentialityLevel</code> - Level of data confidentiality. There are currently 2 levels. Future releases may define more levels.</li>
<li><code>nonce</code> - Used for security.</li>
<li><code>cert</code> - Certificate of the transactor.</li>
<li><code>signature</code> - Signature of the transactor.</li>
<li><code>TransactionPayload.payload</code> - Bytes defining the payload of the transaction. As the payload can be large, only the payload hash is included directly in the transaction message.</li>
</ul>
<p>More detail on transaction security can be found in section 4.</p>
<h5>3.1.2.2 Transaction Specification</h5>
<p>A transaction is always associated with a chaincode specification which defines the chaincode and the execution environment such as language and security context. Currently there is an implementation that uses Golang for writing chaincode. Other languages may be added in the future.</p>
<pre><code>message ChaincodeSpec {
    enum Type {
        UNDEFINED = 0;
        GOLANG = 1;
        NODE = 2;
    }
    Type type = 1;
    ChaincodeID chaincodeID = 2;
    ChaincodeInput input = 3;
    int32 timeout = 4;
    string secureContext = 5;
    ConfidentialityLevel confidentialityLevel = 6;
    bytes metadata = 7;
}

message ChaincodeID {
    string path = 1;
    string name = 2;
}

message ChaincodeInput {
    string function = 1;
    repeated string args  = 2;
}
</code></pre>
<p><strong>Definition of fields:</strong></p>
<ul>
<li><code>chaincodeID</code> - The chaincode source code path and name.</li>
<li><code>input</code> - Function name and argument parameters to call.</li>
<li><code>timeout</code> - Time in milliseconds to execute the transaction.</li>
<li><code>confidentialityLevel</code> - Confidentiality level of this transaction.</li>
<li><code>secureContext</code> - Security context of the transactor.</li>
<li><code>metadata</code> - Any data the application wants to pass along.</li>
</ul>
<p>The peer, receiving the <code>chaincodeSpec</code>, wraps it in an appropriate transaction message and broadcasts to the network.</p>
<h5>3.1.2.3 Deploy Transaction</h5>
<p>Transaction <code>type</code> of a deploy transaction is <code>CHAINCODE_DEPLOY</code> and the payload contains an object of <code>ChaincodeDeploymentSpec</code>.</p>
<pre><code>message ChaincodeDeploymentSpec {
    ChaincodeSpec chaincodeSpec = 1;
    google.protobuf.Timestamp effectiveDate = 2;
    bytes codePackage = 3;
}
</code></pre>
<p><strong>Definition of fields:</strong></p>
<ul>
<li><code>chaincodeSpec</code> - See section 3.1.2.2, above.</li>
<li><code>effectiveDate</code> - Time when the chaincode is ready to accept invocations.</li>
<li><code>codePackage</code> - gzip of the chaincode source.</li>
</ul>
<p>The validating peers always verify the hash of the <code>codePackage</code> when they deploy the chaincode to make sure the package has not been tampered with since the deploy transaction entered the network.</p>
<h5>3.1.2.4 Invoke Transaction</h5>
<p>Transaction <code>type</code> of an invoke transaction is <code>CHAINCODE_INVOKE</code> and the <code>payload</code> contains an object of <code>ChaincodeInvocationSpec</code>.</p>
<pre><code>message ChaincodeInvocationSpec {
    ChaincodeSpec chaincodeSpec = 1;
}
</code></pre>
<h5>3.1.2.5 Query Transaction</h5>
<p>A query transaction is similar to an invoke transaction, but the message <code>type</code> is <code>CHAINCODE_QUERY</code>.</p>
<h4>3.1.3 Synchronization Messages</h4>
<p>Synchronization protocol starts with discovery, described above in section 3.1.1, when a peer realizes that it's behind or its current block is not the same with others. A peer broadcasts either <code>SYNC_GET_BLOCKS</code>, <code>SYNC_STATE_GET_SNAPSHOT</code>, or <code>SYNC_STATE_GET_DELTAS</code> and receives <code>SYNC_BLOCKS</code>, <code>SYNC_STATE_SNAPSHOT</code>, or <code>SYNC_STATE_DELTAS</code> respectively.</p>
<p>The installed consensus plugin (e.g. pbft) dictates how synchronization protocol is being applied. Each message is designed for a specific situation:</p>
<p><strong>SYNC_GET_BLOCKS</strong> requests for a range of contiguous blocks expressed in the message <code>payload</code>, which is an object of <code>SyncBlockRange</code>. The correlationId specified is included in the <code>SyncBlockRange</code> of any replies to this message.</p>
<pre><code>message SyncBlockRange {
    uint64 correlationId = 1;
    uint64 start = 2;
    uint64 end = 3;
}
</code></pre>
<p>A receiving peer responds with a <code>SYNC_BLOCKS</code> message whose <code>payload</code> contains an object of <code>SyncBlocks</code></p>
<pre><code>message SyncBlocks {
    SyncBlockRange range = 1;
    repeated Block blocks = 2;
}
</code></pre>
<p>The <code>start</code> and <code>end</code> indicate the starting and ending blocks inclusively. The order in which blocks are returned is defined by the <code>start</code> and <code>end</code> values. For example, if <code>start</code>=3 and <code>end</code>=5, the order of blocks will be 3, 4, 5. If <code>start</code>=5 and <code>end</code>=3, the order will be 5, 4, 3.</p>
<p><strong>SYNC_STATE_GET_SNAPSHOT</strong> requests for the snapshot of the current world state. The <code>payload</code> is an object of <code>SyncStateSnapshotRequest</code></p>
<pre><code>message SyncStateSnapshotRequest {
  uint64 correlationId = 1;
}
</code></pre>
<p>The <code>correlationId</code> is used by the requesting peer to keep track of the response messages. A receiving peer replies with <code>SYNC_STATE_SNAPSHOT</code> message whose <code>payload</code> is an instance of <code>SyncStateSnapshot</code></p>
<pre><code>message SyncStateSnapshot {
    bytes delta = 1;
    uint64 sequence = 2;
    uint64 blockNumber = 3;
    SyncStateSnapshotRequest request = 4;
}
</code></pre>
<p>This message contains the snapshot or a chunk of the snapshot on the stream, and in which case, the sequence indicate the order starting at 0. The terminating message will have len(delta) == 0.</p>
<p><strong>SYNC_STATE_GET_DELTAS</strong> requests for the state deltas of a range of contiguous blocks. By default, the Ledger maintains 500 transition deltas. A delta(j) is a state transition between block(i) and block(j) where i = j-1. The message <code>payload</code> contains an instance of <code>SyncStateDeltasRequest</code></p>
<pre><code>message SyncStateDeltasRequest {
    SyncBlockRange range = 1;
}
</code></pre>
<p>A receiving peer responds with <code>SYNC_STATE_DELTAS</code>, whose <code>payload</code> is an instance of <code>SyncStateDeltas</code></p>
<pre><code>message SyncStateDeltas {
    SyncBlockRange range = 1;
    repeated bytes deltas = 2;
}
</code></pre>
<p>A delta may be applied forward (from i to j) or backward (from j to i) in the state transition.</p>
<h4>3.1.4 Consensus Messages</h4>
<p>Consensus deals with transactions, so a <code>CONSENSUS</code> message is initiated internally by the consensus framework when it receives a <code>CHAIN_TRANSACTION</code> message. The framework converts <code>CHAIN_TRANSACTION</code> into <code>CONSENSUS</code> then broadcasts to the validating nodes with the same <code>payload</code>. The consensus plugin receives this message and process according to its internal algorithm. The plugin may create custom subtypes to manage consensus finite state machine. See section 3.4 for more details.</p>
<h3>3.2 Ledger</h3>
<p>The ledger consists of two primary pieces, the blockchain and the world state. The blockchain is a series of linked blocks that is used to record transactions within the ledger. The world state is a key-value database that chaincodes may use to store state when executed by a transaction.</p>
<h4>3.2.1 Blockchain</h4>
<h5>3.2.1.1 Block</h5>
<p>The blockchain is defined as a linked list of blocks as each block contains the hash of the previous block in the chain. The two other important pieces of information that a block contains are the list of transactions contained within the block and the hash of the world state after executing all transactions in the block.</p>
<pre><code>message Block {
  version = 1;
  google.protobuf.Timestamp timestamp = 2;
  bytes transactionsHash = 3;
  bytes stateHash = 4;
  bytes previousBlockHash = 5;
  bytes consensusMetadata = 6;
  NonHashData nonHashData = 7;
}

message BlockTransactions {
  repeated Transaction transactions = 1;
}
</code></pre>
<ul>
<li><code>version</code> - Version used to track any protocol changes.</li>
<li><code>timestamp</code> - The timestamp to be filled in by the block proposer.</li>
<li><code>transactionsHash</code> - The merkle root hash of the block's transactions.</li>
<li><code>stateHash</code> - The merkle root hash of the world state.</li>
<li><code>previousBlockHash</code> - The hash of the previous block.</li>
<li><code>consensusMetadata</code> - Optional metadata that the consensus may include in a block.</li>
<li><code>nonHashData</code> - A <code>NonHashData</code> message that is set to nil before computing the hash of the block, but stored as part of the block in the database.</li>
<li><code>BlockTransactions.transactions</code> - An array of Transaction messages. Transactions are not included in the block directly due to their size.</li>
</ul>
<h5>3.2.1.2 Block Hashing</h5>
<ul>
<li>
<p>The <code>previousBlockHash</code> hash is calculated using the following algorithm.</p>
<ol>
<li>
<p>Serialize the Block message to bytes using the protocol buffer library.</p>
</li>
<li>
<p>Hash the serialized block message to 512 bits of output using the SHA3 SHAKE256 algorithm as described in <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">FIPS 202</a>.</p>
</li>
</ol>
</li>
<li>
<p>The <code>transactionHash</code> is the root of the transaction merkle tree. Defining the merkle tree implementation is a TODO.</p>
</li>
<li>
<p>The <code>stateHash</code> is defined in section 3.2.2.1.</p>
</li>
</ul>
<h5>3.2.1.3 NonHashData</h5>
<p>The NonHashData message is used to store block metadata that is not required to be the same value on all peers. These are suggested values.</p>
<pre><code>message NonHashData {
  google.protobuf.Timestamp localLedgerCommitTimestamp = 1;
  repeated TransactionResult transactionResults = 2;
}

message TransactionResult {
  string uuid = 1;
  bytes result = 2;
  uint32 errorCode = 3;
  string error = 4;
}
</code></pre>
<ul>
<li>
<p><code>localLedgerCommitTimestamp</code> - A timestamp indicating when the block was commited to the local ledger.</p>
</li>
<li>
<p><code>TransactionResult</code> - An array of transaction results.</p>
</li>
<li>
<p><code>TransactionResult.uuid</code> - The ID of the transaction.</p>
</li>
<li>
<p><code>TransactionResult.result</code> - The return value of the transaction.</p>
</li>
<li>
<p><code>TransactionResult.errorCode</code> - A code that can be used to log errors associated with the transaction.</p>
</li>
<li>
<p><code>TransactionResult.error</code> - A string that can be used to log errors associated with the transaction.</p>
</li>
</ul>
<h5>3.2.1.4 Transaction Execution</h5>
<p>A transaction defines either the deployment of a chaincode or the execution of a chaincode. All transactions within a block are run before recording a block in the ledger. When chaincodes execute, they may modify the world state. The hash of the world state is then recorded in the block.</p>
<h4>3.2.2 World State</h4>
<p>The <em>world state</em> of a peer refers to the collection of the <em>states</em> of all the deployed chaincodes. Further, the state of a chaincode is represented as a collection of key-value pairs. Thus, logically, the world state of a peer is also a collection of key-value pairs where key consists of a tuple <code>{chaincodeID, ckey}</code>. Here, we use the term <code>key</code> to represent a key in the world state i.e., a tuple <code>{chaincodeID, ckey}</code> and we use the term <code>cKey</code> to represent a unique key within a chaincode.</p>
<p>For the purpose of the description below, <code>chaincodeID</code> is assumed to be a valid utf8 string and <code>ckey</code> and the <code>value</code> can be a sequence of one or more arbitrary bytes.</p>
<h5>3.2.2.1 Hashing the world state</h5>
<p>During the functioning of a network, many occasions such as committing transactions and synchronizing peers may require computing a crypto-hash of the world state observed by a peer. For instance, the consensus protocol may require to ensure that a <em>minimum</em> number of peers in the network observe the same world state.</p>
<p>Since, computing the crypto-hash of the world state could be an expensive operation, this is highly desirable to organize the world state such that it enables an efficient crypto-hash computation of the world state when a change occurs in the world state. Further, different organization designs may be suitable under different workloads conditions.</p>
<p>Because the fabric is expected to function under a variety of scenarios leading to different workloads conditions, a pluggable mechanism is supported for organizing the world state.</p>
<h6>3.2.2.1.1 Bucket-tree</h6>
<p><em>Bucket-tree</em> is one of the implementations for organizing the world state. For the purpose of the description below, a key in the world state is represented as a concatenation of the two components (<code>chaincodeID</code> and <code>ckey</code>)  separated by a <code>nil</code> byte i.e., <code>key</code> = <code>chaincodeID</code>+<code>nil</code>+<code>cKey</code>.</p>
<p>This method models a <em>merkle-tree</em> on top of buckets of a <em>hash table</em> in order to compute the crypto-hash of the <em>world state</em>.</p>
<p>At the core of this method, the <em>key-values</em> of the world state are assumed to be stored in a hash-table that consists of a pre-decided number of buckets (<code>numBuckets</code>). A hash function (<code>hashFunction</code>) is employed to determine the bucket number that should contain a given key. Please note that the <code>hashFunction</code> does not represent a crypto-hash method such as SHA3, rather this is a regular programming language hash function that decides the bucket number for a given key.</p>
<p>For modeling the merkle-tree, the ordered buckets act as leaf nodes of the tree - lowest numbered bucket being the left most leaf node in the tree. For constructing the second-last level of the tree, a pre-decided number of leaf nodes (<code>maxGroupingAtEachLevel</code>), starting from left, are grouped together and for each such group, a node is inserted at the second-last level that acts as a common parent for all the leaf nodes in the group. Note that the number of children for the last parent node may be less than <code>maxGroupingAtEachLevel</code>. This grouping method of constructing the next higher level is repeated until the root node of the tree is constructed.</p>
<p>An example setup with configuration <code>{numBuckets=10009 and maxGroupingAtEachLevel=10}</code> will result in a tree with number of nodes at different level as depicted in the following table.</p>
<table>
<thead>
<tr>
<th>Level</th>
<th align="center">Number of nodes</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td align="center">1</td>
</tr>
<tr>
<td>1</td>
<td align="center">2</td>
</tr>
<tr>
<td>2</td>
<td align="center">11</td>
</tr>
<tr>
<td>3</td>
<td align="center">101</td>
</tr>
<tr>
<td>4</td>
<td align="center">1001</td>
</tr>
<tr>
<td>5</td>
<td align="center">10009</td>
</tr></tbody></table>
<p>For computing the crypto-hash of the world state, the crypto-hash of each bucket is computed and is assumed to be the crypto-hash of leaf-nodes of the merkle-tree. In order to compute crypto-hash of a bucket, the key-values present in the bucket are first serialized and crypto-hash function is applied on the serialized bytes. For serializing the key-values of a bucket, all the key-values with a common chaincodeID prefix are serialized separately and then appending together, in the ascending order of chaincodeIDs. For serializing the key-values of a chaincodeID, the following information is concatenated:</p>
<ol>
<li>Length of chaincodeID (number of bytes in the chaincodeID)</li>
</ol>
<ul>
<li>The utf8 bytes of the chaincodeID</li>
<li>Number of key-values for the chaincodeID</li>
<li>For each key-value (in sorted order of the ckey)
<ul>
<li>Length of the ckey</li>
<li>ckey bytes</li>
<li>Length of the value</li>
<li>value bytes</li>
</ul>
</li>
</ul>
<p>For all the numeric types in the above list of items (e.g., Length of chaincodeID), protobuf's varint encoding is assumed to be used. The purpose of the above encoding is to achieve a byte representation of the key-values within a bucket that can not be arrived at by any other combination of key-values and also to reduce the overall size of the serialized bytes.</p>
<p>For example, consider a bucket that contains three key-values namely, <code>chaincodeID1_key1:value1, chaincodeID1_key2:value2, and chaincodeID2_key1:value1</code>. The serialized bytes for the bucket would logically look as - <code>12 + chaincodeID1 + 2 + 4 + key1 + 6 + value1 + 4 + key2 + 6 + value2 + 12 + chaincodeID2 + 1 + 4 + key1 + 6 + value1</code></p>
<p>If a bucket has no key-value present, the crypto-hash is considered as <code>nil</code>.</p>
<p>The crypto-hash of an intermediate node and root node are computed just like in a standard merkle-tree i.e., applying a crypto-hash function on the bytes obtained by concatenating the crypto-hash of all the children nodes, from left to right. Further, if a child has a crypto-hash as <code>nil</code>, the crypto-hash of the child is omitted when concatenating the children crypto-hashes. If the node has a single child, the crypto-hash of the child is assumed to be the crypto-hash of the node. Finally, the crypto-hash of the root node is considered as the crypto-hash of the world state.</p>
<p>The above method offers performance benefits for computing crypto-hash when a few key-values change in the state. The major benefits include</p>
<ul>
<li>Computation of crypto-hashes of the unchanged buckets can be skipped</li>
<li>The depth and breadth of the merkle-tree can be controlled by configuring the parameters <code>numBuckets</code> and <code>maxGroupingAtEachLevel</code>. Both depth and breadth of the tree has different implication on the performance cost incurred by and resource demand of different resources (namely - disk I/O, storage, and memory)</li>
</ul>
<p>In a particular deployment, all the peer nodes are expected to use same values for the configurations <code>numBuckets, maxGroupingAtEachLevel, and hashFunction</code>. Further, if any of these configurations are to be changed at a later stage, the configurations should be changed on all the peer nodes so that the comparison of crypto-hashes across peer nodes is meaningful. Also, this may require to migrate the existing data based on the implementation. For example, an implementation is expected to store the last computed crypto-hashes for all the nodes in the tree which would need to be recalculated.</p>
<h3>3.3 Chaincode</h3>
<p>Chaincode is an application-level code deployed as a transaction (see section 3.1.2) to be distributed to the network and managed by each validating peer as isolated sandbox. Though any virtualization technology can support the sandbox, currently Docker container is utilized to run the chaincode. The protocol described in this section enables different virtualization support implementation to plug and play.</p>
<h4>3.3.1 Virtual Machine Instantiation</h4>
<p>A virtual machine implements the VM interface:</p>
<pre><code>type VM interface {
	build(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool, reader io.Reader) error
	start(ctxt context.Context, id string, args []string, env []string, attachstdin bool, attachstdout bool) error
	stop(ctxt context.Context, id string, timeout uint, dontkill bool, dontremove bool) error
}
</code></pre>
<p>The fabric instantiates the VM when it processes a Deploy transaction or other transactions on the chaincode while the VM for that chaincode is not running (either crashed or previously brought down due to inactivity). Each chaincode image is built by the <code>build</code> function, started by <code>start</code> and stopped by <code>stop</code> function.</p>
<p>Once the chaincode container is up, it makes a gRPC connection back to the validating peer that started the chaincode, and that establishes the channel for Invoke and Query transactions on the chaincode.</p>
<h4>3.3.2 Chaincode Protocol</h4>
<p>Communication between a validating peer and its chaincodes is based on a bidirectional gRPC stream. There is a shim layer on the chaincode container to handle the message protocol between the chaincode and the validating peer using protobuf message.</p>
<pre><code>message ChaincodeMessage {

    enum Type {
        UNDEFINED = 0;
        REGISTER = 1;
        REGISTERED = 2;
        INIT = 3;
        READY = 4;
        TRANSACTION = 5;
        COMPLETED = 6;
        ERROR = 7;
        GET_STATE = 8;
        PUT_STATE = 9;
        DEL_STATE = 10;
        INVOKE_CHAINCODE = 11;
        INVOKE_QUERY = 12;
        RESPONSE = 13;
        QUERY = 14;
        QUERY_COMPLETED = 15;
        QUERY_ERROR = 16;
        RANGE_QUERY_STATE = 17;
    }

    Type type = 1;
    google.protobuf.Timestamp timestamp = 2;
    bytes payload = 3;
    string uuid = 4;
}
</code></pre>
<p><strong>Definition of fields:</strong></p>
<ul>
<li><code>Type</code> is the type of the message.</li>
<li><code>payload</code> is the payload of the message. Each payload depends on the <code>Type</code>.</li>
<li><code>uuid</code> is a unique identifier of the message.</li>
</ul>
<p>The message types are described in the following sub-sections.</p>
<p>A chaincode implements the <code>Chaincode</code> interface, which is called by the validating peer when it processes Deploy, Invoke or Query transactions.</p>
<pre><code>type Chaincode interface {
i	Init(stub *ChaincodeStub, function string, args []string) ([]byte, error)
	Invoke(stub *ChaincodeStub, function string, args []string) ([]byte, error)
	Query(stub *ChaincodeStub, function string, args []string) ([]byte, error)
}
</code></pre>
<p><code>Init</code>, <code>Invoke</code> and <code>Query</code> functions take <code>function</code> and <code>args</code> as parameters to be used by those methods to support a variety of transactions. <code>Init</code> is a constructor function, which will only be invoked by the Deploy transaction. The <code>Query</code> function is not allowed to modify the state of the chaincode; it can only read and calculate the return value as a byte array.</p>
<h5>3.3.2.1 Chaincode Deploy</h5>
<p>Upon deploy (chaincode container is started), the shim layer sends a one time <code>REGISTER</code> message to the validating peer with the <code>payload</code> containing the <code>ChaincodeID</code>. The validating peer responds with <code>REGISTERED</code> or <code>ERROR</code> on success or failure respectively. The shim closes the connection and exits if it receives an <code>ERROR</code>.</p>
<p>After registration, the validating peer sends <code>INIT</code> with the <code>payload</code> containing a <code>ChaincodeInput</code> object. The shim calls the <code>Init</code> function with the parameters from the <code>ChaincodeInput</code>, enabling the chaincode to perform any initialization, such as setting up the persistent state.</p>
<p>The shim responds with <code>RESPONSE</code> or <code>ERROR</code> message depending on the returned value from the chaincode <code>Init</code> function. If there are no errors, the chaincode initialization is complete and is ready to receive Invoke and Query transactions.</p>
<h5>3.3.2.2 Chaincode Invoke</h5>
<p>When processing an invoke transaction, the validating peer sends a <code>TRANSACTION</code> message to the chaincode container shim, which in turn calls the chaincode <code>Invoke</code> function, passing the parameters from the <code>ChaincodeInput</code> object. The shim responds to the validating peer with <code>RESPONSE</code> or <code>ERROR</code> message, indicating the completion of the function. If <code>ERROR</code> is received, the <code>payload</code> contains the error message generated by the chaincode.</p>
<h5>3.3.2.3 Chaincode Query</h5>
<p>Similar to an invoke transaction, when processing a query, the validating peer sends a <code>QUERY</code> message to the chaincode container shim, which in turn calls the chaincode <code>Query</code> function, passing the parameters from the <code>ChaincodeInput</code> object. The <code>Query</code> function may return a state value or an error, which the shim forwards to the validating peer using <code>RESPONSE</code> or <code>ERROR</code> messages respectively.</p>
<h5>3.3.2.4 Chaincode State</h5>
<p>Each chaincode may define its own persistent state variables. For example, a chaincode may create assets such as TVs, cars, or stocks using state variables to hold the assets attributes. During <code>Invoke</code> function processing, the chaincode may update the state variables, for example, changing an asset owner. A chaincode manipulates the state variables by using the following message types:</p>
<h6>PUT_STATE</h6>
<p>Chaincode sends a <code>PUT_STATE</code> message to persist a key-value pair, with the <code>payload</code> containing <code>PutStateInfo</code> object.</p>
<pre><code>message PutStateInfo {
    string key = 1;
    bytes value = 2;
}
</code></pre>
<h6>GET_STATE</h6>
<p>Chaincode sends a <code>GET_STATE</code> message to retrieve the value whose key is specified in the <code>payload</code>.</p>
<h6>DEL_STATE</h6>
<p>Chaincode sends a <code>DEL_STATE</code> message to delete the value whose key is specified in the <code>payload</code>.</p>
<h6>RANGE_QUERY_STATE</h6>
<p>Chaincode sends a <code>RANGE_QUERY_STATE</code> message to get a range of values. The message <code>payload</code> contains a <code>RangeQueryStateInfo</code> object.</p>
<pre><code>message RangeQueryState {
	string startKey = 1;
	string endKey = 2;
}
</code></pre>
<p>The <code>startKey</code> and <code>endKey</code> are inclusive and assumed to be in lexical order. The validating peer responds with <code>RESPONSE</code> message whose <code>payload</code> is a <code>RangeQueryStateResponse</code> object.</p>
<pre><code>message RangeQueryStateResponse {
    repeated RangeQueryStateKeyValue keysAndValues = 1;
    bool hasMore = 2;
    string ID = 3;
}
message RangeQueryStateKeyValue {
    string key = 1;
    bytes value = 2;
}
</code></pre>
<p>If <code>hasMore=true</code> in the response, this indicates that additional keys are available in the requested range. The chaincode can request the next set of keys and values by sending a <code>RangeQueryStateNext</code> message with an ID that matches the ID returned in the response.</p>
<pre><code>message RangeQueryStateNext {
    string ID = 1;
}
</code></pre>
<p>When the chaincode is finished reading from the range, it should send a <code>RangeQueryStateClose</code> message with the ID it wishes to close.</p>
<pre><code>message RangeQueryStateClose {
  string ID = 1;
}
</code></pre>
<h6>INVOKE_CHAINCODE</h6>
<p>Chaincode may call another chaincode in the same transaction context by sending an <code>INVOKE_CHAINCODE</code> message to the validating peer with the <code>payload</code> containing a <code>ChaincodeSpec</code> object.</p>
<h6>QUERY_CHAINCODE</h6>
<p>Chaincode may query another chaincode in the same transaction context by sending a <code>QUERY_CHAINCODE</code> message with the <code>payload</code> containing a <code>ChaincodeSpec</code> object.</p>
<h3>3.4 Pluggable Consensus Framework</h3>
<p>The consensus framework defines the interfaces that every consensus <em>plugin</em> implements:</p>
<ul>
<li><code>consensus.Consenter</code>: interface that  allows consensus plugin to receive messages from the network.</li>
<li><code>consensus.CPI</code>:  <em>Consensus Programming Interface</em> (<code>CPI</code>) is used by consensus plugin to interact with rest of the stack. This interface is split in two parts:
<ul>
<li><code>consensus.Communicator</code>: used to send (broadcast and unicast) messages to other validating peers.</li>
<li><code>consensus.LedgerStack</code>: which is used as an interface to the execution framework as well as the ledger.</li>
</ul>
</li>
</ul>
<p>As described below in more details, <code>consensus.LedgerStack</code> encapsulates, among other interfaces, the <code>consensus.Executor</code> interface, which is the key part of the consensus framework. Namely, <code>consensus.Executor</code> interface allows for a (batch of) transaction to be started, executed, rolled back if necessary, previewed, and potentially committed. A particular property that every consensus plugin needs to satisfy is that batches (blocks)  of transactions are committed to the ledger (via <code>consensus.Executor.CommitTxBatch</code>) in total order across all validating peers (see <code>consensus.Executor</code> interface description below for more details).</p>
<p>Currently, consensus framework consists of 3 packages <code>consensus</code>, <code>controller</code>, and <code>helper</code>. The primary reason for <code>controller</code> and <code>helper</code> packages is to avoid "import cycle" in Go (golang) and minimize code changes for plugin to update.</p>
<ul>
<li><code>controller</code> package specifies the consensus plugin used by a validating peer.</li>
<li><code>helper</code> package is a shim around a consensus plugin that helps it interact with the rest of the stack, such as maintaining message handlers to other peers.</li>
</ul>
<p>There are 2 consensus plugins provided: <code>pbft</code> and <code>noops</code>:</p>
<ul>
<li><code>pbft</code> package contains consensus plugin that implements the <em>PBFT</em> [1] consensus protocol. See section 5 for more detail.</li>
<li><code>noops</code> is a ''dummy'' consensus plugin for development and test purposes. It doesn't perform consensus but processes all consensus messages. It also serves as a good simple sample to start learning how to code a consensus plugin.</li>
</ul>
<h4>3.4.1 <code>Consenter</code> interface</h4>
<p>Definition:</p>
<pre><code>type Consenter interface {
	RecvMsg(msg *pb.Message) error
}
</code></pre>
<p>The plugin's entry point for (external) client requests, and consensus messages generated internally (i.e. from the consensus module) during the consensus process. The <code>controller.NewConsenter</code> creates the plugin <code>Consenter</code>. <code>RecvMsg</code> processes the incoming transactions in order to reach consensus.</p>
<p>See <code>helper.HandleMessage</code> below to understand how the peer interacts with this interface.</p>
<h4>3.4.2 <code>CPI</code> interface</h4>
<p>Definition:</p>
<pre><code>type CPI interface {
	Inquirer
	Communicator
	SecurityUtils
	LedgerStack
}
</code></pre>
<p><code>CPI</code> allows the plugin to interact with the stack. It is implemented by the <code>helper.Helper</code> object. Recall that this object:</p>
<ol>
<li>Is instantiated when the <code>helper.NewConsensusHandler</code> is called.</li>
<li>Is accessible to the plugin author when they construct their plugin's <code>consensus.Consenter</code> object.</li>
</ol>
<h4>3.4.3 <code>Inquirer</code> interface</h4>
<p>Definition:</p>
<pre><code>type Inquirer interface {
        GetNetworkInfo() (self *pb.PeerEndpoint, network []*pb.PeerEndpoint, err error)
        GetNetworkHandles() (self *pb.PeerID, network []*pb.PeerID, err error)
}
</code></pre>
<p>This interface is a part of the <code>consensus.CPI</code> interface. It is used to get the handles of the validating peers in the network (<code>GetNetworkHandles</code>) as well as details about the those validating peers (<code>GetNetworkInfo</code>):</p>
<p>Note that the peers are identified by a <code>pb.PeerID</code> object. This is a protobuf message (in the <code>protos</code> package), currently defined as (notice that this definition will likely be modified):</p>
<pre><code>message PeerID {
    string name = 1;
}
</code></pre>
<h4>3.4.4 <code>Communicator</code> interface</h4>
<p>Definition:</p>
<pre><code>type Communicator interface {
	Broadcast(msg *pb.Message) error
	Unicast(msg *pb.Message, receiverHandle *pb.PeerID) error
}
</code></pre>
<p>This interface is a part of the <code>consensus.CPI</code> interface. It is used to communicate with other peers on the network (<code>helper.Broadcast</code>, <code>helper.Unicast</code>):</p>
<h4>3.4.5 <code>SecurityUtils</code> interface</h4>
<p>Definition:</p>
<pre><code>type SecurityUtils interface {
        Sign(msg []byte) ([]byte, error)
        Verify(peerID *pb.PeerID, signature []byte, message []byte) error
}
</code></pre>
<p>This interface is a part of the <code>consensus.CPI</code> interface. It is used to handle the cryptographic operations of message signing (<code>Sign</code>) and verifying signatures (<code>Verify</code>)</p>
<h4>3.4.6 <code>LedgerStack</code> interface</h4>
<p>Definition:</p>
<pre><code>type LedgerStack interface {
	Executor
	Ledger
	RemoteLedgers
}
</code></pre>
<p>A key member of the <code>CPI</code> interface, <code>LedgerStack</code> groups interaction of consensus with the rest of the fabric, such as the execution of transactions, querying, and updating the ledger. This interface supports querying the local blockchain and state, updating the local blockchain and state, and querying the blockchain and state of other nodes in the consensus network. It consists of three parts: <code>Executor</code>, <code>Ledger</code> and <code>RemoteLedgers</code> interfaces. These are described in the following.</p>
<h4>3.4.7 <code>Executor</code> interface</h4>
<p>Definition:</p>
<pre><code>type Executor interface {
	BeginTxBatch(id interface{}) error
	ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error)  
	CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error  
	RollbackTxBatch(id interface{}) error  
	PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error)  
}
</code></pre>
<p>The executor interface is the most frequently utilized portion of the <code>LedgerStack</code> interface, and is the only piece which is strictly necessary for a consensus network to make progress. The interface allows for a transaction to be started, executed, rolled back if necessary, previewed, and potentially committed. This interface is comprised of the following methods.</p>
<h5>3.4.7.1 Beginning a transaction batch</h5>
<pre><code>BeginTxBatch(id interface{}) error
</code></pre>
<p>This call accepts an arbitrary <code>id</code>, deliberately opaque, as a way for the consensus plugin to ensure only the transactions associated with this particular batch are executed. For instance, in the pbft implementation, this <code>id</code> is the an encoded hash of the transactions to be executed.</p>
<h5>3.4.7.2 Executing transactions</h5>
<pre><code>ExecTXs(id interface{}, txs []*pb.Transaction) ([]byte, []error)
</code></pre>
<p>This call accepts an array of transactions to execute against the current state of the ledger and returns the current state hash in addition to an array of errors corresponding to the array of transactions. Note that a transaction resulting in an error has no effect on whether a transaction batch is safe to commit. It is up to the consensus plugin to determine the behavior which should occur when failing transactions are encountered. This call is safe to invoke multiple times.</p>
<h5>3.4.7.3 Committing and rolling-back transactions</h5>
<pre><code>RollbackTxBatch(id interface{}) error
</code></pre>
<p>This call aborts an execution batch. This will undo the changes to the current state, and restore the ledger to its previous state. It concludes the batch begun with <code>BeginBatchTx</code> and a new one must be created before executing any transactions.</p>
<pre><code>PreviewCommitTxBatchBlock(id interface{}, transactions []*pb.Transaction, metadata []byte) (*pb.Block, error)
</code></pre>
<p>This call is most useful for consensus plugins which wish to test for non-deterministic transaction execution. The hashable portions of the block returned are guaranteed to be identical to the block which would be committed if <code>CommitTxBatch</code> were immediately invoked. This guarantee is violated if any new transactions are executed.</p>
<pre><code>CommitTxBatch(id interface{}, transactions []*pb.Transaction, transactionsResults []*pb.TransactionResult, metadata []byte) error
</code></pre>
<p>This call commits a block to the blockchain. Blocks must be committed to a blockchain in total order. <code>CommitTxBatch</code> concludes the transaction batch, and a new call to <code>BeginTxBatch</code> must be made before any new transactions are executed and committed.</p>
<h4>3.4.8 <code>Ledger</code> interface</h4>
<p>Definition:</p>
<pre><code>type Ledger interface {
	ReadOnlyLedger
	UtilLedger
	WritableLedger
}
</code></pre>
<p><code>Ledger</code> interface is intended to allow the consensus plugin to interrogate and possibly update the current state and blockchain. It is comprised of the three interfaces described below.</p>
<h5>3.4.8.1 <code>ReadOnlyLedger</code> interface</h5>
<p>Definition:</p>
<pre><code>type ReadOnlyLedger interface {
	GetBlock(id uint64) (block *pb.Block, err error)
	GetCurrentStateHash() (stateHash []byte, err error)
	GetBlockchainSize() (uint64, error)
}
</code></pre>
<p><code>ReadOnlyLedger</code> interface is intended to query the local copy of the ledger without the possibility of modifying it. It is comprised of the following functions.</p>
<pre><code>GetBlockchainSize() (uint64, error)
</code></pre>
<p>This call returns the current length of the blockchain ledger. In general, this function should never fail, though in the unlikely event that this occurs, the error is passed to the caller to decide what if any recovery is necessary. The block with the highest number will have block number <code>GetBlockchainSize()-1</code>.</p>
<p>Note that in the event that the local copy of the blockchain ledger is corrupt or incomplete, this call will return the highest block number in the chain, plus one. This allows for a node to continue operating from the current state/block even when older blocks are corrupt or missing.</p>
<pre><code>GetBlock(id uint64) (block *pb.Block, err error)
</code></pre>
<p>This call returns the block from the blockchain with block number <code>id</code>. In general, this call should not fail, except when the block queried exceeds the current blocklength, or when the underlying blockchain has somehow become corrupt. A failure of <code>GetBlock</code> has a possible resolution of using the state transfer mechanism to retrieve it.</p>
<pre><code>GetCurrentStateHash() (stateHash []byte, err error)
</code></pre>
<p>This call returns the current state hash for the ledger. In general, this function should never fail, though in the unlikely event that this occurs, the error is passed to the caller to decide what if any recovery is necessary.</p>
<h5>3.4.8.2 <code>UtilLedger</code> interface</h5>
<p>Definition:</p>
<pre><code>type UtilLedger interface {
	HashBlock(block *pb.Block) ([]byte, error)
	VerifyBlockchain(start, finish uint64) (uint64, error)
}
</code></pre>
<p><code>UtilLedger</code>  interface defines some useful utility functions which are provided by the local ledger. Overriding these functions in a mock interface can be useful for testing purposes. This interface is comprised of two functions.</p>
<pre><code>HashBlock(block *pb.Block) ([]byte, error)
</code></pre>
<p>Although <code>*pb.Block</code> has a <code>GetHash</code> method defined, for mock testing, overriding this method can be very useful. Therefore, it is recommended that the <code>GetHash</code> method never be directly invoked, but instead invoked via this <code>UtilLedger.HashBlock</code> interface. In general, this method should never fail, but the error is still passed to the caller to decide what if any recovery is appropriate.</p>
<pre><code>VerifyBlockchain(start, finish uint64) (uint64, error)
</code></pre>
<p>This utility method is intended for verifying large sections of the blockchain. It proceeds from a high block <code>start</code> to a lower block <code>finish</code>, returning the block number of the first block whose <code>PreviousBlockHash</code> does not match the block hash of the previous block as well as an error. Note, this generally indicates the last good block number, not the first bad block number.</p>
<h5>3.4.8.3 <code>WritableLedger</code> interface</h5>
<p>Definition:</p>
<pre><code>type WritableLedger interface {
	PutBlock(blockNumber uint64, block *pb.Block) error
	ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error
	CommitStateDelta(id interface{}) error
	RollbackStateDelta(id interface{}) error
	EmptyState() error
}
</code></pre>
<p><code>WritableLedger</code>  interface allows for the caller to update the blockchain. Note that this is <em>NOT</em> intended for use in normal operation of a consensus plugin. The current state should be modified by executing transactions using the <code>Executor</code> interface, and new blocks will be generated when transactions are committed. This interface is instead intended primarily for state transfer or corruption recovery. In particular, functions in this interface should <em>NEVER</em> be exposed directly via consensus messages, as this could result in violating the immutability promises of the blockchain concept. This interface is comprised of the following functions.</p>
<ul>
<li>
<pre><code>PutBlock(blockNumber uint64, block *pb.Block) error
</code></pre>
<p>This function takes a provided, raw block, and inserts it into the blockchain at the given blockNumber. Note that this intended to be an unsafe interface, so no error or sanity checking is performed. Inserting a block with a number higher than the current block height is permitted, similarly overwriting existing already committed blocks is also permitted. Remember, this does not affect the auditability or immutability of the chain, as the hashing techniques make it computationally infeasible to forge a block earlier in the chain. Any attempt to rewrite the blockchain history is therefore easily detectable. This is generally only useful to the state transfer API.</p>
</li>
<li>
<pre><code>ApplyStateDelta(id interface{}, delta *statemgmt.StateDelta) error
</code></pre>
<p>This function takes a state delta, and applies it to the current state. The delta will be applied to transition a state forward or backwards depending on the construction of the state delta. Like the <code>Executor</code> methods, <code>ApplyStateDelta</code> accepts an opaque interface <code>id</code> which should also be passed into <code>CommitStateDelta</code> or <code>RollbackStateDelta</code> as appropriate.</p>
</li>
<li>
<pre><code>CommitStateDelta(id interface{}) error
</code></pre>
<p>This function commits the state delta which was applied in <code>ApplyStateDelta</code>. This is intended to be invoked after the caller to <code>ApplyStateDelta</code> has verified the state via the state hash obtained via <code>GetCurrentStateHash()</code>. This call takes the same <code>id</code> which was passed into <code>ApplyStateDelta</code>.</p>
</li>
<li>
<pre><code>RollbackStateDelta(id interface{}) error
</code></pre>
<p>This function unapplies a state delta which was applied in <code>ApplyStateDelta</code>. This is intended to be invoked after the caller to <code>ApplyStateDelta</code> has detected the state hash obtained via <code>GetCurrentStateHash()</code> is incorrect. This call takes the same <code>id</code> which was passed into <code>ApplyStateDelta</code>.</p>
</li>
<li>
<pre><code>EmptyState() error
</code></pre>
<p>This function will delete the entire current state, resulting in a pristine empty state. It is intended to be called before loading an entirely new state via deltas. This is generally only useful to the state transfer API.</p>
</li>
</ul>
<h4>3.4.9 <code>RemoteLedgers</code> interface</h4>
<p>Definition:</p>
<pre><code>type RemoteLedgers interface {
	GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error)
	GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error)
	GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error)
}
</code></pre>
<p>The <code>RemoteLedgers</code> interface exists primarily to enable state transfer and to interrogate the blockchain state at  other replicas. Just like the <code>WritableLedger</code> interface, it is not intended to be used in normal operation and is designed to be used for catchup, error recovery, etc. For all functions in this interface it is the caller's responsibility to enforce timeouts. This interface contains the following functions.</p>
<ul>
<li>
<pre><code>GetRemoteBlocks(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncBlocks, error)
</code></pre>
<p>This function attempts to retrieve a stream of <code>*pb.SyncBlocks</code> from the peer designated by <code>peerID</code> for the range from <code>start</code> to <code>finish</code>. In general, <code>start</code> should be specified with a higher block number than <code>finish</code>, as the blockchain must be validated from end to beginning. The caller must validate that the desired block is being returned, as it is possible that slow results from another request could appear on this channel. Invoking this call for the same <code>peerID</code> a second time will cause the first channel to close.</p>
</li>
<li>
<pre><code>GetRemoteStateSnapshot(peerID uint64) (&lt;-chan *pb.SyncStateSnapshot, error)
</code></pre>
<p>This function attempts to retrieve a stream of <code>*pb.SyncStateSnapshot</code> from the peer designated by <code>peerID</code>. To apply the result, the existing state should first be emptied via the <code>WritableLedger</code> <code>EmptyState</code> call, then the contained deltas in the stream should be applied sequentially.</p>
</li>
<li>
<pre><code>GetRemoteStateDeltas(peerID uint64, start, finish uint64) (&lt;-chan *pb.SyncStateDeltas, error)
</code></pre>
<p>This function attempts to retrieve a stream of <code>*pb.SyncStateDeltas</code> from the peer designated by <code>peerID</code> for the range from <code>start</code> to <code>finish</code>. The caller must validated that the desired block delta is being returned, as it is possible that slow results from another request could appear on this channel. Invoking this call for the same <code>peerID</code> a second time will cause the first channel to close.</p>
</li>
</ul>
<h4>3.4.10 <code>controller</code> package</h4>
<h5>3.4.10.1 controller.NewConsenter</h5>
<p>Signature:</p>
<pre><code>func NewConsenter(cpi consensus.CPI) (consenter consensus.Consenter)
</code></pre>
<p>This function reads the <code>peer.validator.consensus</code> value in <code>core.yaml</code> configuration file, which is the  configuration file for the <code>peer</code> process. The value of the <code>peer.validator.consensus</code> key defines whether the validating peer will run with the <code>noops</code> consensus plugin or the <code>pbft</code> one. (Notice that this should eventually be changed to either <code>noops</code> or <code>custom</code>. In case of <code>custom</code>, the validating peer will run with the consensus plugin defined in <code>consensus/config.yaml</code>.)</p>
<p>The plugin author needs to edit the function's body so that it routes to the right constructor for their package. For example, for <code>pbft</code> we point to the <code>pbft.GetPlugin</code> constructor.</p>
<p>This function is called by <code>helper.NewConsensusHandler</code> when setting the <code>consenter</code> field of the returned message handler. The input argument <code>cpi</code> is the output of the <code>helper.NewHelper</code> constructor and implements the <code>consensus.CPI</code> interface.</p>
<h4>3.4.11 <code>helper</code> package</h4>
<h5>3.4.11.1 High-level overview</h5>
<p>A validating peer establishes a message handler (<code>helper.ConsensusHandler</code>) for every connected peer, via the <code>helper.NewConsensusHandler</code> function (a handler factory). Every incoming message is inspected on its type (<code>helper.HandleMessage</code>); if it's a message for which consensus needs to be reached, it's passed on to the peer's consenter object (<code>consensus.Consenter</code>). Otherwise it's passed on to the next message handler in the stack.</p>
<h5>3.4.11.2 helper.ConsensusHandler</h5>
<p>Definition:</p>
<pre><code>type ConsensusHandler struct {
	chatStream  peer.ChatStream
	consenter   consensus.Consenter
	coordinator peer.MessageHandlerCoordinator
	done        chan struct{}
	peerHandler peer.MessageHandler
}
</code></pre>
<p>Within the context of consensus, we focus only on the <code>coordinator</code> and <code>consenter</code> fields. The <code>coordinator</code>, as the name implies, is used to coordinate between the peer's message handlers. This is, for instance, the object that is accessed when the peer wishes to <code>Broadcast</code>. The <code>consenter</code> receives the messages for which consensus needs to be reached and processes them.</p>
<p>Notice that <code>fabric/peer/peer.go</code> defines the <code>peer.MessageHandler</code> (interface), and <code>peer.MessageHandlerCoordinator</code> (interface) types.</p>
<h5>3.4.11.3 helper.NewConsensusHandler</h5>
<p>Signature:</p>
<pre><code>func NewConsensusHandler(coord peer.MessageHandlerCoordinator, stream peer.ChatStream, initiatedStream bool, next peer.MessageHandler) (peer.MessageHandler, error)
</code></pre>
<p>Creates a <code>helper.ConsensusHandler</code> object. Sets the same <code>coordinator</code> for every message handler. Also sets the <code>consenter</code> equal to: <code>controller.NewConsenter(NewHelper(coord))</code></p>
<h5>3.4.11.4 helper.Helper</h5>
<p>Definition:</p>
<pre><code>type Helper struct {
	coordinator peer.MessageHandlerCoordinator
}
</code></pre>
<p>Contains the reference to the validating peer's <code>coordinator</code>. Is the object that implements the <code>consensus.CPI</code> interface for the peer.</p>
<h5>3.4.11.5 helper.NewHelper</h5>
<p>Signature:</p>
<pre><code>func NewHelper(mhc peer.MessageHandlerCoordinator) consensus.CPI
</code></pre>
<p>Returns a <code>helper.Helper</code> object whose <code>coordinator</code> is set to the input argument <code>mhc</code> (the <code>coordinator</code> field of the <code>helper.ConsensusHandler</code> message handler). This object implements the <code>consensus.CPI</code> interface, thus allowing the plugin to interact with the stack.</p>
<h5>3.4.11.6 helper.HandleMessage</h5>
<p>Recall that the <code>helper.ConsensusHandler</code> object returned by <code>helper.NewConsensusHandler</code> implements the <code>peer.MessageHandler</code> interface:</p>
<pre><code>type MessageHandler interface {
	RemoteLedger
	HandleMessage(msg *pb.Message) error
	SendMessage(msg *pb.Message) error
	To() (pb.PeerEndpoint, error)
	Stop() error
}
</code></pre>
<p>Within the context of consensus, we focus only on the <code>HandleMessage</code> method. Signature:</p>
<pre><code>func (handler *ConsensusHandler) HandleMessage(msg *pb.Message) error
</code></pre>
<p>The function inspects the <code>Type</code> of the incoming <code>Message</code>. There are four cases:</p>
<ol>
<li>Equal to <code>pb.Message_CONSENSUS</code>: passed to the handler's <code>consenter.RecvMsg</code> function.</li>
<li>Equal to <code>pb.Message_CHAIN_TRANSACTION</code> (i.e. an external deployment request): a response message is sent to the user first, then the message is passed to the <code>consenter.RecvMsg</code> function.</li>
<li>Equal to <code>pb.Message_CHAIN_QUERY</code> (i.e. a query): passed to the <code>helper.doChainQuery</code> method so as to get executed locally.</li>
<li>Otherwise: passed to the <code>HandleMessage</code> method of the next handler down the stack.</li>
</ol>
<h3>3.5 Events</h3>
<p>The event framework provides the ability to generate and consume predefined and custom events. There are 3 basic components:</p>
<ul>
<li>Event stream</li>
<li>Event adapters</li>
<li>Event structures</li>
</ul>
<h4>3.5.1 Event Stream</h4>
<p>An event stream is a gRPC channel capable of sending and receiving events. Each consumer establishes an event stream to the event framework and expresses the events that it is interested in. the event producer only sends appropriate events to the consumers who have connected to the producer over the event stream.</p>
<p>The event stream initializes the buffer and timeout parameters. The buffer holds the number of events waiting for delivery, and the timeout has 3 options when the buffer is full:</p>
<ul>
<li>If timeout is less than 0, drop the newly arriving events</li>
<li>If timeout is 0, block on the event until the buffer becomes available</li>
<li>If timeout is greater than 0, wait for the specified timeout and drop the event if the buffer remains full after the timeout</li>
</ul>
<h5>3.5.1.1 Event Producer</h5>
<p>The event producer exposes a function to send an event, <code>Send(e *pb.Event)</code>, where <code>Event</code> is either a pre-defined <code>Block</code> or a <code>Generic</code> event. More events will be defined in the future to include other elements of the fabric.</p>
<pre><code>message Generic {
    string eventType = 1;
    bytes payload = 2;
}
</code></pre>
<p>The <code>eventType</code> and <code>payload</code> are freely defined by the event producer. For example, JSON data may be used in the <code>payload</code>. The <code>Generic</code> event may also be emitted by the chaincode or plugins to communicate with consumers.</p>
<h5>3.5.1.2 Event Consumer</h5>
<p>The event consumer enables external applications to listen to events. Each event consumer registers an event adapter with the event stream. The consumer framework can be viewed as a bridge between the event stream and the adapter. A typical use of the event consumer framework is:</p>
<pre><code>adapter = &lt;adapter supplied by the client application to register and receive events&gt;
consumerClient = NewEventsClient(&lt;event consumer address&gt;, adapter)
consumerClient.Start()
...
...
consumerClient.Stop()
</code></pre>
<h4>3.5.2 Event Adapters</h4>
<p>The event adapter encapsulates three facets of event stream interaction:</p>
<ul>
<li>an interface that returns the list of all events of interest</li>
<li>an interface called by the event consumer framework on receipt of an event</li>
<li>an interface called by the event consumer framework when the event bus terminates</li>
</ul>
<p>The reference implementation provides Golang specific language binding.</p>
<pre><code>      EventAdapter interface {
         GetInterestedEvents() ([]*ehpb.Interest, error)
         Recv(msg *ehpb.Event) (bool,error)
         Disconnected(err error)
      }
</code></pre>
<p>Using gRPC as the event bus protocol allows the event consumer framework to be ported to different language bindings without affecting the event producer framework.</p>
<h4>3.5.3 Event Structure</h4>
<p>This section details the message structures of the event system. Messages are described directly in Golang for simplicity.</p>
<p>The core message used for communication between the event consumer and producer is the Event.</p>
<pre><code>    message Event {
        oneof Event {
            //consumer events
            Register register = 1;

            //producer events
            Block block = 2;
            Generic generic = 3;
       }
    }
</code></pre>
<p>Per the above definition, an event has to be one of <code>Register</code>, <code>Block</code> or <code>Generic</code>.</p>
<p>As mentioned in the previous sections, a consumer creates an event bus by establishing a connection with the producer and sending a <code>Register</code> event. The <code>Register</code> event is essentially an array of <code>Interest</code> messages declaring the events of interest to the consumer.</p>
<pre><code>    message Interest {
        enum ResponseType {
            //don't send events (used to cancel interest)
            DONTSEND = 0;
            //send protobuf objects
            PROTOBUF = 1;
            //marshall into JSON structure
            JSON = 2;
        }
        string eventType = 1;
        ResponseType responseType = 2;
    }
</code></pre>
<p>Events can be sent directly as protobuf structures or can be sent as JSON structures by specifying the <code>responseType</code> appropriately.</p>
<p>Currently, the producer framework can generate a <code>Block</code> or a <code>Generic</code> event. A <code>Block</code> is a message used for encapsulating properties of a block in the blockchain.</p>
<h2>4. Security</h2>
<p>This section discusses the setting depicted in the figure below.<br>
In particular, the system consists of the following entities:<br>
membership management infrastructure, i.e., a set of entities that are<br>
responsible for identifying an individual user (using any form of identification<br>
considered in the system, e.g., credit cards, id-cards), open an account for<br>
that user to be able to register, and issue the necessary credentials to<br>
successfully create transactions and deploy or invoke chaincode successfully<br>
through the fabric.<br>
<a href="./images/sec-sec-arch.png" target="_blank"><img src="./images/sec-sec-arch.png" alt="figure-architecture" style="max-width:100%;"></a></p>
<ul>
<li>Peers, that are classified as validating peers, and non-validating peers.<br>
Validating peers (also known as validators) order and process (check validity, execute,<br>
and add to the blockchain) user-messages (transactions) submitted to the network.<br>
Non validating peers (also known as peers) receive user transactions on behalf of users,<br>
and after some fundamental validity checks, they forward the transactions to their<br>
neighboring validating peers. Peers maintain an up-to-date copy of the blockchain,<br>
but in contradiction to validators, they do not execute transactions<br>
(a process also known as <em>transaction validation</em>).</li>
<li>End users of the system, that have registered to our membership service administration,<br>
after having demonstrated ownership of what is considered <em>identity</em> in the system,<br>
and have obtained credentials to install the client-software and submit transactions<br>
to the system.</li>
<li>Client-software, the software that needs to be installed at the client side for the<br>
latter to be able to complete his registration to our membership service and submit<br>
transactions to the system.</li>
<li>Online wallets, entities that are trusted by a user to maintain that user's credentials,<br>
and submit transactions solely upon user request to the network. Online wallets come<br>
with their own software at the client-side, that is usually light-weight, as the<br>
client only needs to authenticate himself and his requests to the wallet.<br>
While it can be the case that peers can play the role of <em>online wallet</em> for a set of<br>
users, in the following sessions the security of online wallets is detailed separately.</li>
</ul>
<p>Users who wish to make use of the fabric, open an account at the membership management<br>
administration, by proving ownership of identity as discussed in previous sections, new chaincodes<br>
are announced to the blockchain network by the chaincode creator (developer) through the means<br>
of a deployment transaction that the client-software would construct on behalf of the developer.<br>
Such transaction is first received by a peer or validator, and afterwards circulated<br>
in the entire network of validators, this transaction is executed and finds its place to<br>
the blockchain network. Users can also invoke a function of an already deployed chain-code<br>
through an invocation transaction.</p>
<p>The next section provides a summary of the business goals of the system that drive the security requirements. We then overview the security components and their operation and show how this design fulfills the security requirements.</p>
<h3>4.1 Business security requirements</h3>
<p>This section presents business security requirements that are relevant to the context of the fabric.<br>
<strong>Incorporation of identity and role management.</strong></p>
<p>In order to adequately support real business applications it is necessary to progress beyond ensuring cryptographic continuity. A workable B2B system must consequently move towards addressing proven/demonstrated identities or other attributes relevant to conducting business. Business transactions and consumer interactions with financial institutions need to be unambiguously mapped to account holders. Business contracts typically require demonstrable affiliation with specific institutions and/or possession of other specific properties of transacting parties. Accountability and non-frameability are two reasons that identity management is a critical component of such systems.</p>
<p>Accountability means that users of the system, individuals, or corporations, who misbehave can be traced back and be set accountable for their actions. In many cases, members of a B2B system are required to use their identities (in some form) to participate in the system, in a way such that accountability is guaranteed. Accountability and non-frameability are both essential security requirements in B2B systems and they are closely related. That is, a B2B system should guarantee that an honest user of such system cannot be framed to be accused as responsible for transactions originated by other users.</p>
<p>In addition a B2B system should be renewable and flexible in order to accommodate changes of participants’s roles and/or affiliations.</p>
<p><strong>Transactional privacy.</strong></p>
<p>In B2B relationships there is a strong need for transactional privacy, i.e., allowing the end-user of a system to control the degree to which it interacts and shares information with its environment. For example, a corporation doing business through a transactional B2B system requires that its transactions are not visible to other corporations or industrial partners that are not authorized to share classified information with.</p>
<p>Transactional privacy in the fabric is offered by the mechanisms to achieve two properties with respect to non authorized users:</p>
<ul>
<li>
<p>Transaction anonymity, where the owner of a transaction is hidden among the so called <em>anonymity set</em>, which in the fabric, is the set of users.</p>
</li>
<li>
<p>Transaction unlinkability, where two or more transactions of the same user should not be linked as such.</p>
</li>
</ul>
<p>Clearly depending on the context, non-authorized users can be anyone outside the system, or a subset of users.</p>
<p>Transactional privacy is strongly associated to the confidentiality of the content of a contractual agreement between two or more members of a B2B system, as well as to the anonymity and unlinkability of any authentication mechanism that should be in place within transactions.</p>
<p><strong>Reconciling transactional privacy with identity management.</strong></p>
<p>As described later in this document, the approach taken here to reconcile identity management with user privacy and to enable competitive institutions to transact effectively on a common blockchain (for both intra- and inter-institutional transactions) is as follows:</p>
<ol>
<li>
<p>add certificates to transactions to implement a “permissioned” blockchain</p>
</li>
<li>
<p>utilize a two-level system:</p>
<ol>
<li>
<p>(relatively) static enrollment certificates (ECerts), acquired via registration with an enrollment certificate authority (CA).</p>
</li>
<li>
<p>transaction certificates (TCerts) that faithfully but pseudonymously represent enrolled users, acquired via a transaction CA.</p>
</li>
</ol>
</li>
<li>
<p>offer mechanisms to conceal the content of transactions to unauthorized members of the system.</p>
</li>
</ol>
<p><strong>Audit support.</strong> Commercial systems are occasionally subjected to audits. Auditors in such cases should be given the means to check a certain transaction, or a certain group of transactions, the activity of a particular user of the system, or the operation of the system itself. Thus, such capabilities should be offered by any system featuring transactions containing contractual agreements between business partners.</p>
<h3>4.2 User Privacy through Membership Services</h3>
<p>Membership Services consists of an infrastructure of several entities that together manage the identity and privacy of users on the network. These services validate user’s identity, register the user in the system, and provide all the credentials needed for him/her to be an active and compliant participant able to create and/or invoke transactions. A Public Key Infrastructure (PKI) is a framework based on public key cryptography that ensures not only the secure exchange of data over public networks but also affirms the identity of the other party. A PKI manages the generation, distribution and revocation of keys and digital certificates. Digital certificates are used to establish user credentials and to sign messages. Signing messages with a certificate ensures that the message has not been altered. Typically a PKI has a Certificate Authority (CA), a Registration Authority (RA), a certificate database, and a certificate storage. The RA is a trusted party that authenticates users and vets the legitimacy of data, certificates or other evidence submitted to support the user’s request for one or more certificates that reflect that user’s identity or other properties. A CA, upon advice from an RA, issues digital certificates for specific uses and is certified directly or hierarchically by a root CA. Alternatively, the user-facing communications and due diligence responsibilities of the RA can be subsumed as part of the CA. Membership Services is composed of the entities shown in the following figure. Introduction of such full PKI reinforces the strength of this system for B2B (over, e.g. Bitcoin).</p>
<p><a href="./images/sec-memserv-components.png" target="_blank"><img src="./images/sec-memserv-components.png" alt="Figure 1" style="max-width:100%;"></a></p>
<p><em>Root Certificate Authority (Root CA):</em> entity that represents the trust anchor for the PKI scheme. Digital certificates verification follows a chain of trust. The Root CA is the top-most CA in the PKI hierarchy.</p>
<p><em>Registration Authority (RA):</em> a trusted entity that can ascertain the validity and identity of users who want to participate in the permissioned blockchain. It is responsible for out-of-band communication with the user to validate his/her identity and role. It creates registration credentials needed for enrollment and information on root of trust.</p>
<p><em>Enrollment Certificate Authority (ECA):</em>  responsible for issuing Enrollment Certificates (ECerts) after validating the registration credentials provided by the user.</p>
<p><em>Transaction Certificate Authority (TCA):</em> responsible for issuing Transaction Certificates (TCerts) after validating the enrollment credentials provided by the user.</p>
<p><em>TLS Certificate Authority (TLS-CA):</em> responsible for issuing TLS certificates and credentials that allow the user to make use of its network. It validates the credential(s) or evidence provided by the user that justifies issuance of a TLS certificate that includes specific information pertaining to the user.</p>
<p>In this specification, membership services is expressed through the following associated certificates issued by the PKI:</p>
<p><em>Enrollment Certificates (ECerts)</em><br>
ECerts are long-term certificates. They are issued for all roles, i.e. users, non-validating peers, and validating peers. In the case of users, who submit transactions for candidate incorporation into the blockchain and who also own TCerts (discussed below), there are two possible structure and usage models for ECerts:</p>
<ul>
<li>
<p>Model A:  ECerts contain the identity/enrollmentID of their owner and can be used to offer only nominal entity-authentication for TCert requests and/or within transactions. They contain the public part of two key pairs – a signature key-pair and an encryption/key agreement key-pair. ECerts are accessible to everyone.</p>
</li>
<li>
<p>Model B: ECerts contain the identity/enrollmentID of their owner and can be used to offer only nominal entity-authentication for TCert requests. They contain the public part of a signature key-pair, i.e., a signature verification public key. ECerts are preferably accessible to only TCA and auditors, as relying parties. They are invisible to transactions, and thus (unlike TCerts) their signature key pairs do not play a non-repudiation role at that level.</p>
</li>
</ul>
<p><em>Transaction Certificates (TCerts)</em><br>
TCerts are short-term certificates for each transaction. They are issued by the TCA upon authenticated user-request. They securely authorize a transaction and may be configured to not reveal the identities of who is involved in the transaction or to selectively reveal such identity/enrollmentID information. They include the public part of a signature key-pair, and may be configured to also include the public part of a key agreement key pair. They are issued only to users. They are uniquely associated to the owner – they may be configured so that this association is known only by the TCA (and to authorized auditors). TCerts may be configured to not carry information of the identity of the user. They enable the user not only to anonymously participate in the system but also prevent linkability of transactions.</p>
<p>However, auditability and accountability requirements assume that the TCA is able to retrieve TCerts of a given identity, or retrieve the owner of a specific TCert. For details on how TCerts are used in deployment and invocation transactions see Section 4.3, Transaction Security offerings at the infrastructure level.</p>
<p>TCerts can accommodate encryption or key agreement public keys (as well as digital signature verification public keys).<br>
If TCerts are thus equipped, then enrollment certificates need not also contain encryption or key agreement public keys.</p>
<p>Such a key agreement public key, Key_Agreement_TCertPub_Key, can be generated by the transaction certificate authority (TCA) using a method that is the same as that used to generate the Signature_Verification_TCertPub_Key, but using an index value of TCertIndex + 1 rather than TCertIndex, where TCertIndex is hidden within the TCert by the TCA for recovery by the TCert owner.</p>
<p>The structure of a Transaction Certificate (TCert) is as follows:</p>
<ul>
<li>TCertID – transaction certificate ID (preferably generated by TCA randomly in order to avoid unintended linkability via the Hidden Enrollment ID field).</li>
<li>Hidden Enrollment ID: AES_Encrypt<sub>K</sub>(enrollmentID), where key K = [HMAC(Pre-K, TCertID)]<sub>256-bit truncation</sub> and where three distinct key distribution scenarios for Pre-K are defined below as (a), (b) and (c).</li>
<li>Hidden Private Keys Extraction: AES_Encrypt<sub>TCertOwner_EncryptKey</sub>(TCertIndex || known padding/parity check vector) where || denotes concatenation, and where each batch has a unique (per batch) time-stamp/random offset that is added to a counter (initialized at 1 in this implementation) in order to generate TCertIndex. The counter can be incremented by 2 each time in order to accommodate generation by the TCA of the public keys and recovery by the TCert owner of the private keys of both types, i.e., signature key pairs and key agreement key pairs.</li>
<li>Sign Verification Public Key – TCert signature verification public key.</li>
<li>Key Agreement Public Key – TCert key agreement public key.</li>
<li>Validity period – the time window during which the transaction certificate can be used for the outer/external signature of a transaction.</li>
</ul>
<p>There are at least three useful ways to consider configuring the key distribution scenario for the Hidden Enrollment ID field:<br>
<em>(a)</em> Pre-K is distributed during enrollment to user clients, peers and auditors, and is available to the TCA and authorized auditors. It may, for example, be derived from K<sub>chain</sub> (described subsequently in this specification) or be independent of key(s) used for chaincode confidentiality.</p>
<p><em>(b)</em> Pre-K is available to validators, the TCA and authorized auditors. K is made available by a validator to a user (under TLS) in response to a successful query transaction. The query transaction can have the same format as the invocation transaction. Corresponding to Example 1 below, the querying user would learn the enrollmentID of the user who created the Deployment Transaction if the querying user owns one of the TCerts in the ACL of the Deployment Transaction. Corresponding to Example 2 below, the querying user would learn the enrollmentID of the user who created the Deployment Transaction if the enrollmentID of the TCert used to query matches one of the affiliations/roles in the Access Control field of the Deployment Transaction.</p>
<p><em>Example 1:</em></p>
<p><a href="./images/sec-example-1.png" target="_blank"><img src="./images/sec-example-1.png" alt="Example 1" style="max-width:100%;"></a></p>
<p><em>Example 2:</em></p>
<p><a href="./images/sec-example-2.png" target="_blank"><img src="./images/sec-example-2.png" alt="Example 2" style="max-width:100%;"></a></p>
<p><em>(c)</em> Pre-K is available to the TCA and authorized auditors. The TCert-specific K can be distributed the TCert owner (under TLS) along with the TCert, for each TCert in the batch. This enables targeted release by the TCert owner of K (and thus trusted notification of the TCert owner’s enrollmentID). Such targeted release can use key agreement public keys of the intended recipients and/or PK<sub>chain</sub> where SK<sub>chain</sub> is available to validators as described subsequently in this specification. Such targeted release to other contract participants can be incorporated into a transaction or done out-of-band.</p>
<p>If the TCerts are used in conjunction with ECert Model A above, then using (c) where K is not distributed to the TCert owner may suffice.<br>
If the TCerts are used in conjunction with ECert Model A above, then the Key Agreement Public Key field of the TCert may not be necessary.</p>
<p>The Transaction Certificate Authority (TCA) returns TCerts in batches, each batch contains the KeyDF_Key (Key-Derivation-Function Key) which is not included within every TCert but delivered to the client with the batch of TCerts (using TLS). The KeyDF_Key allows the TCert owner to derive TCertOwner_EncryptKey which in turn enables recovery of TCertIndex from AES_Encrypt<sub>TCertOwner_EncryptKey</sub>(TCertIndex || known padding/parity check vector).</p>
<p><em>TLS-Certificates (TLS-Certs)</em><br>
TLS-Certs are certificates used for system/component-to-system/component communications. They carry the identity of their owner and are used for network level security.</p>
<p>This implementation of membership services provides the following basic functionality: there is no expiration/revocation of ECerts; expiration of TCerts is provided via the validity period time window; there is no revocation of TCerts. The ECA, TCA, and TLS CA certificates are self-signed, where the TLS CA is provisioned as a trust anchor.</p>
<h4>4.2.1 User/Client Enrollment Process</h4>
<p>The next figure has a high-level description of the user enrollment process. It has an offline and an online phase.</p>
<p><a href="./images/sec-registration-high-level.png" target="_blank"><img src="./images/sec-registration-high-level.png" alt="Registration" style="max-width:100%;"></a></p>
<p><em>Offline Process:</em> in Step 1, each user/non-validating peer/validating peer has to present strong identification credentials (proof of ID) to a Registration Authority (RA) offline. This has to be done out-of-band to provide the evidence needed by the RA to create (and store) an account for the user. In Step 2, the RA returns the associated username/password and trust anchor (TLS-CA Cert in this implementation) to the user. If the user has access to a local client then this is one way the client can be securely provisioned with the TLS-CA certificate as trust anchor.</p>
<p><em>Online Phase:</em> In Step 3, the user connects to the client to request to be enrolled in the system. The user sends his username and password to the client. On behalf of the user, the client sends the request to the PKI framework, Step 4, and receives a package, Step 5, containing several certificates, some of which should correspond to private/secret keys held by the client. Once the client verifies that the all the crypto material in the package is correct/valid, it stores the certificates in local storage and notifies the user. At this point the user enrollment has been completed.</p>
<p><a href="./images/sec-registration-detailed.png" target="_blank"><img src="./images/sec-registration-detailed.png" alt="Figure 4" style="max-width:100%;"></a></p>
<p>Figure 4 shows a detailed description of the enrollment process. The PKI framework has the following entities – RA, ECA, TCA and TLS-CA. After Step 1, the RA calls the function “AddEntry” to enter the (username/password) in its database. At this point the user has been formally registered into the system database. The client needs the TLS-CA certificate (as trust anchor) to verify that the TLS handshake is set up appropriately with the server. In Step 4, the client sends the registration request to the ECA along with its enrollment public key and additional identity information such as username and password (under the TLS record layer protocol). The ECA verifies that such user really exists in the database. Once it establishes this assurance the user has the right to submit his/her enrollment public key and the ECA will certify it. This enrollment information is of a one-time use. The ECA updates the database marking that this registration request information (username/password) cannot be used again. The ECA constructs, signs and sends back to the client an enrollment certificate (ECert) that contains the user’s enrollment public key (Step 5). It also sends the ECA Certificate (ECA-Cert) needed in future steps (client will need to prove to the TCA that his/her ECert was created by the proper ECA). (Although the ECA-Cert is self-signed in the initial implementation, the TCA and TLS-CA and ECA are co-located.) The client verifies, in Step 6, that the public key inside the ECert is the one originally submitted by the client (i.e. that the ECA is not cheating). It also verifies that all the expected information within the ECert is present and properly formed.</p>
<p>Similarly, In Step 7, the client sends a registration request to the TLS-CA along with its public key and identity information. The TLS-CA verifies that such user is in the database. The TLS-CA generates, and signs a TLS-Cert that contains the user’s TLS public key (Step 8). TLS-CA sends the TLS-Cert and its certificate (TLS-CA Cert). Step 9 is analogous to Step 6, the client verifies that the public key inside the TLS Cert is the one originally submitted by the client and that the information in the TLS Cert is complete and properly formed. In Step 10, the client saves all certificates in local storage for both certificates. At this point the user enrollment has been completed.</p>
<p>In this implementation the enrollment process for validators is the same as that for peers. However, it is possible that a different implementation would have validators enroll directly through an on-line process.</p>
<p><a href="./images/sec-request-tcerts-deployment.png" target="_blank"><img src="./images/sec-request-tcerts-deployment.png" alt="Figure 5" style="max-width:100%;"></a><br>
<a href="./images/sec-request-tcerts-invocation.png" target="_blank"><img src="./images/sec-request-tcerts-invocation.png" alt="Figure 6" style="max-width:100%;"></a></p>
<p><em>Client:</em> Request for TCerts batch needs to include (in addition to count), ECert and signature of request using ECert private key (where Ecert private key is pulled from Local Storage).</p>
<p><em>TCA generates TCerts for batch:</em> Generates key derivation function key, KeyDF_Key, as HMAC(TCA_KDF_Key, EnrollPub_Key). Generates each TCert public key (using TCertPub_Key = EnrollPub_Key + ExpansionValue G, where 384-bit ExpansionValue = HMAC(Expansion_Key, TCertIndex) and 384-bit Expansion_Key = HMAC(KeyDF_Key, “2”)). Generates each AES_Encrypt<sub>TCertOwner_EncryptKey</sub>(TCertIndex || known padding/parity check vector), where || denotes concatenation and where TCertOwner_EncryptKey is derived as [HMAC(KeyDF_Key, “1”)]<sub>256-bit truncation</sub>.</p>
<p><em>Client:</em> Deriving TCert private key from a TCert in order to be able to deploy or invoke or query: KeyDF_Key and ECert private key need to be pulled from Local Storage. KeyDF_Key is used to derive TCertOwner_EncryptKey as [HMAC(KeyDF_Key, “1”)]<sub>256-bit truncation</sub>; then TCertOwner_EncryptKey is used to decrypt the TCert field AES_Encrypt<sub>TCertOwner_EncryptKey</sub>(TCertIndex || known padding/parity check vector); then TCertIndex is used to derive TCert private key: TCertPriv_Key = (EnrollPriv_Key + ExpansionValue) modulo n, where 384-bit ExpansionValue = HMAC(Expansion_Key, TCertIndex) and 384-bit Expansion_Key = HMAC(KeyDF_Key, “2”).</p>
<h4>4.2.2 Expiration and revocation of certificates</h4>
<p>It is practical to support expiration of transaction certificates. The time window during which a transaction certificate can be used is expressed by a ‘validity period’ field. The challenge regarding support of expiration lies in the distributed nature of the system. That is, all validating entities must share the same information; i.e. be consistent with respect to the expiration of the validity period associated with the transactions to be executed and validated. To guarantee that the expiration of validity periods is done in a consistent manner across all validators, the concept of validity period identifier is introduced. This identifier acts as a logical clock enabling the system to uniquely identify a validity period. At genesis time the “current validity period” of the chain gets initialized by the TCA. It is essential that this validity period identifier is given monotonically increasing values over time, such that it imposes a total order among validity periods.</p>
<p>A special type of transactions, system transactions, and the validity period identified are used together to announce the expiration of a validity period to the Blockchain. System transactions refer to contracts that have been defined in the genesis block and are part of the infrastructure. The validity period identified is updated periodically by the TCA invoking a system chaincode. Note that only the TCA should be allowed to update the validity period. The TCA sets the validity period for each transaction certificate by setting the appropriate integer values in the following two fields that define a range: ‘not-before’ and ‘not-after’ fields.</p>
<p>TCert Expiration:<br>
At the time of processing a TCert, validators read from the state table associated with the ledger the value of ‘current validity period’ to check if the outer certificate associated with the transaction being evaluated is currently valid. That is, the current value in the state table has to be within the range defined by TCert sub-fields ‘not-before’ and ‘not-after’. If this is the case, the validator continues processing the transaction. In the case that the current value is not within range, the TCert has expired or is not yet valid and the validator should stop processing the transaction.</p>
<p>ECert Expiration:<br>
Enrollment certificates have different validity period length(s) than those in transaction certificates.</p>
<p>Revocation is supported in the form of Certificate Revocation Lists (CRLs). CRLs identify revoked certificates. Changes to the CRLs, incremental differences, are announced through the Blockchain.</p>
<h3>4.3 Transaction security offerings at the infrastructure level</h3>
<p>Transactions in the fabric are user-messages submitted to be included<br>
in the ledger. As discussed in previous sections, these messages have a<br>
specific structure, and enable users to deploy new chaincodes, invoke existing<br>
chaincodes, or query the state of existing chaincodes.<br>
Therefore, the way transactions are formed, announced and processed plays<br>
an important role to the privacy and security offerings of the entire system.</p>
<p>On one hand our membership service provides the means to authenticate transactions as<br>
having originated by valid users of the system, to disassociate transactions with user identities,<br>
but while efficiently tracing the transactions a particular individual under certain conditions<br>
(law enforcement, auditing). In other words, membership services offer to transactions authentication<br>
mechanisms that marry user-privacy with accountability and non-repudiation.</p>
<p>On the other hand, membership services alone cannot offer full privacy of user-activities within<br>
the fabric. First of all, for privacy provisions offered by the fabric to be complete,<br>
privacy-preserving authentication mechanisms need to be accompanied by transaction confidentiality.<br>
This becomes clear if one considers that the content of a chaincode, may leak information on who may have<br>
created it, and thus break the privacy of that chaincode's creator. The first subsection<br>
discusses transaction confidentiality.</p>


<p>Enforcing access control for the invocation of chaincode is an important security requirement.<br>
The fabric exposes to the application (e.g., chaincode creator) the means for the application<br>
to perform its own invocation access control, while leveraging the fabric's membership services.<br>
Section 4.4 elaborates on this.</p>

<p>Replay attacks is another crucial aspect of the security of the chaincode,<br>
as a malicious user may copy a transaction that was added to the Blockchain<br>
in the past, and replay it in the network to distort its operation.<br>
This is the topic of Section 4.3.3.</p>
<p>The rest of this Section presents an overview of how security mechanisms in the<br>
infrastructure are incorporated in the transactions' lifecycle,<br>
and details each security mechanism separately.</p>
<h4>4.3.1 Security Lifecycle of Transactions</h4>
<p>Transactions are created on the client side. The client can be either plain<br>
client, or a more specialized application, i.e., piece of<br>
software that handles (server) or invokes (client) specific chaincodes<br>
through the blockchain. Such applications are built on top of the<br>
platform (client) and are detailed in Section 4.4.</p>
<p>Developers of new chaincodes create a new deploy transaction by passing to<br>
the fabric infrastructure:</p>
<ul>
<li>the confidentiality/security version or type they want the transaction to conform with,</li>
<li>the set of users who wish to be given access to parts of the chaincode and<br>
a proper representation of their (read) access rights</li>
</ul>

<ul>
<li>the chaincode specification,</li>
<li>code metadata, containing information that should be passed to the chaincode<br>
at the time of its execution<br>
(e.g., configuration parameters), and</li>
<li>transaction metadata, that is attached to the transaction structure,<br>
and is only used by the application that deployed the chaincode.</li>
</ul>
<p>Invoke and query transactions corresponding to chaincodes with confidentiality<br>
restrictions are created using a similar approach. The transactor provides the<br>
identifier of the chaincode to be executed, the name of the function to be<br>
invoked and its arguments. Optionally, the invoker can pass to the<br>
transaction creation function, code invocation metadata, that will be provided<br>
to the chaincode at the time of its execution. Transaction metadata is another<br>
field that the application of the invoker or the invoker himself can leverage<br>
for their own purposes.</p>
<p>Finally transactions at the client side, are signed by a certificate of their<br>
creator and released to the network of validators.<br>
Validators receive the confidential transactions, and pass them through the following phases:</p>
<ul>
<li><em>pre-validation</em> phase, where validators validate the transaction certificate against the accepted root certificate authority,<br>
verify transaction certificate signature included in the transaction (statically), and check whether the transaction is a replay (see, later section for details on replay attack protection).</li>
<li><em>consensus</em> phase, where the validators add this transaction to the total order of transactions (ultimately included in the ledger)</li>
<li><em>pre-execution</em> phase, where validators verify the validity of the transaction / enrollment certificate against the current validity period,<br>
decrypt the transaction (if the transaction is encrypted), and check that the transaction's plaintext is correctly formed(e.g., invocation access control is respected, included TCerts are correctly formed);<br>
mini replay-attack check is also performed here within the transactions of the currently processed block.</li>
<li><em>execution</em> phase, where the (decrypted) chaincode is passed to a container, along with the associated code metadata, and is executed</li>
<li><em>commit</em> phase, where (encrypted) updates of that chaincodes state is committed to the ledger with the transaction itself.</li>
</ul>
<h4>4.3.2 Transaction confidentiality</h4>
<p>Transaction confidentiality requires that under the request of the developer, the plain-text<br>
of a chaincode, i.e., code, description, is not accessible or inferable (assuming a computational<br>
attacker) by any unauthorized entities(i.e., user or peer not authorized by the developer).<br>
For the latter, it is important that for chaincodes with confidentiality requirements the<br>
content of both <em>deploy</em> and <em>invoke</em> transactions remains concealed. In the same spirit,<br>
non-authorized parties, should not be able to associate invocations (invoke transactions) of a<br>
chaincode to the chaincode itself (deploy transaction) or these invocations to each other.</p>
<p>Additional requirements for any candidate solution is that it respects and supports the privacy<br>
and security provisions of the underlying membership service. In addition, it should not prevent<br>
the enforcement of any invocation access control of the chain-code functions in the fabric, or<br>
the implementation of enforcement of access-control mechanisms on the application (See Subsection 4.4).</p>
<p>In the following is provided the specification of transaction confidentiality<br>
mechanisms at the granularity of users. The last subsection provides some guidelines<br>
on how to extend this functionality at the level of validators.<br>
Information on the features supported in current release and its security<br>
provisions, you can find in Section 4.7.</p>
<p>The goal is to achieve a design that will allow for granting or restricting<br>
access to an entity to any subset of the following parts of a chain-code:</p>
<ol>
<li>chaincode content, i.e., complete (source) code of the<br>
chaincode,</li>
</ol>

<ol start="2">
<li>chaincode function headers, i.e., the prototypes of the functions included in a chaincode,</li>
</ol>


<ol start="3">
<li>chaincode [invocations &amp;] state, i.e., successive updates to the state of a specific chaincode,<br>
when one or more functions of its are invoked</li>
<li>all the above</li>
</ol>
<p>Notice, that this design offers the application the capability to leverage the fabric's<br>
membership service infrastructure and its public key infrastructure to build their own access<br>
control policies and enforcement mechanisms.</p>
<h5>4.3.2.1 Confidentiality against users</h5>
<p>To support fine-grained confidentiality control, i.e., restrict read-access to the<br>
plain-text of a chaincode to a subset of users that the chaincode creator<br>
defines, a chain is bound to a single long-term encryption key-pair<br>
(PK<sub>chain</sub>, SK<sub>chain</sub>).<br>
Though initially this key-pair is to be stored and maintained by each chain's<br>
PKI, in later releases, however, this restriction will be moved away,<br>
as chains (and the associated key-pairs) can be triggered through the Blockchain<br>
by any user with <em>special</em> (admin) privileges (See, Section 4.3.2.2).</p>
<p><strong>Setup</strong>. At enrollment phase, users obtain (as before) an enrollment certificate,<br>
denoted by Cert<sub>u<sub>i</sub></sub> for user u<sub>i</sub>, while each<br>
validator v<sub>j</sub> obtain its enrollment certificate denoted by<br>
Cert<sub>v<sub>j</sub></sub>. Enrollment would grant users and validators the<br>
following credentials:</p>
<ol>
<li>
<p>Users:</p>
<p>a. claim and grant themselves signing key-pair (spk<sub>u</sub>, ssk<sub>u</sub>),</p>
<p>b. claim and grant themselves encryption key-pair (epk<sub>u</sub>, esk<sub>u</sub>),</p>
<p>c. obtain the encryption (public) key of the chain PK<sub>chain</sub></p>
</li>
<li>
<p>Validators:</p>
<p>a. claim and grant themselves signing key-pair (spk<sub>v</sub>, ssk<sub>v</sub>),</p>
<p>b. claim and grant themselves an encryption key-pair (epk<sub>v</sub>, esk<sub>v</sub>),</p>
<p>c. obtain the decryption (secret) key of the chain SK<sub>chain</sub></p>
</li>
</ol>
<p>Thus, enrollment certificates contain the public part of two key-pairs:</p>
<ul>
<li>one signature key-pair [denoted by (spk<sub>v<sub>j</sub></sub>,ssk<sub>v<sub>j</sub></sub>)<br>
for validators and by (spk<sub>u<sub>i</sub></sub>, ssk<sub>u<sub>i</sub></sub>) for users], and</li>
<li>an encryption key-pair [denoted by (epk<sub>v<sub>j</sub></sub>,esk<sub>v<sub>j</sub></sub>)<br>
for validators and (epk<sub>u<sub>i</sub></sub>, esk<sub>u<sub>i</sub></sub>) for users]</li>
</ul>
<p>Chain, validator and user enrollment public keys are accessible to everyone.</p>
<p>In addition to enrollment certificates, users who wish to anonymously<br>
participate in transactions issue transaction certificates. For simplicity<br>
transaction certificates of a user u<sub>i</sub> are denoted by<br>
TCert<sub>u<sub>i</sub></sub>. Transaction certificates include the public part<br>
of a signature key-pair denoted by<br>
(tpk<sub>u<sub>i</sub></sub>,tsk<sub>u<sub>i</sub></sub>).</p>
<p>The following section provides a high level description of how transaction<br>
format accommodates read-access restrictions at the granularity of users.</p>
<p><strong>Structure of deploy transaction.</strong><br>
The following figure depicts the structure of a typical deploy<br>
transaction with confidentiality enabled.</p>
<p><a href="./images/sec-usrconf-deploy.png" target="_blank"><img src="./images/sec-usrconf-deploy.png" alt="FirstRelease-deploy" style="max-width:100%;"></a></p>
<p>One can notice that a deployment transaction consists of several sections:</p>
<ul>
<li>
<p>Section <em>general-info</em>: contains the administration details of the<br>
transaction, i.e., which chain this transaction corresponds to (chained),<br>
the type of transaction (that is set to ''deplTrans''), the version number of<br>
confidentiality policy implemented, its creator identifier (expressed by means<br>
of transaction certificate TCert of enrollment certificate Cert), and a Nonce,<br>
that facilitates primarily replay-attack resistance techniques.</p>
</li>
<li>
<p>Section <em>code-info</em>: contains information on the chain-code source code,<br>
and function headers. As shown in the figure below, there is a symmetric key<br>
used for the source-code of the chaincode (K<sub>C</sub>), and another<br>
symmetric key used for the function prototypes (K<sub>H</sub>). A signature of<br>
the creator of the chaincode is included on the plain-text code such that<br>
the latter cannot be detached from the transaction and replayed by another<br>
party.</p>
</li>
<li>
<p>Section <em>chain-validators</em>: where appropriate key material is passed to the<br>
validators for the latter to be able to (i) decrypt the chain-code source<br>
(K<sub>C</sub>), (ii) decrypt the headers,  and<br>
(iii) encrypt the state when the chain-code has been<br>
invoked accordingly(K<sub>S</sub>). In particular, the chain-code creator<br>
generates an encryption key-pair for the chain-code it deploys<br>
(PK<sub>C</sub>, SK<sub>C</sub>). It then uses PK<sub>C</sub><br>
to encrypt all the keys associated to the chain-code:</p>
 [(''code'',K<sub>C</sub>) ,(''headr'',K<sub>H</sub>),(''code-state'',K<sub>S</sub>), Sig<sub>TCert<sub>u<sub>c</sub></sub></sub>(\*)]<sub>PK<sub>c</sub></sub>, 
and passes the secret key SK<sub>C</sub> to the validators using the
chain-specific public key:
[(''chaincode'',SK<sub>C</sub>), Sig<sub>TCert<sub>u<sub>c</sub></sub></sub>(*)]<sub>PK<sub>chain</sub></sub>.
</li>
<li>
<p>Section <em>contract-users</em>: where the public encryption keys of the contract users,<br>
i.e., users who are given read-access to parts of the chaincode, are used to encrypt<br>
the keys  associated to their access rights:</p>
<ol>
<li>
<p>SK<sub>c</sub> for the users to be able to read any message associated to<br>
that chain-code (invocation, state, etc),</p>
</li>
<li>
<p>K<sub>C</sub> for the user to be able to read only the contract code,</p>
</li>
<li>
<p>K<sub>H</sub> for the user to only be able to read the headers,</p>
</li>
<li>
<p>K<sub>S</sub> for the user to be able to read the state associated to that contract.</p>
</li>
</ol>
<p>Finally users are given the contract's public key PK<sub>c</sub>,<br>
for them to be able to encrypt information related to that contract for the validators<br>
(or any in possession of SK<sub>c</sub>) to be able to read it. Transaction certificate<br>
of each contract user is appended to the transaction and follows that user's message.<br>
This is done for users to be able to easily search the blockchain<br>
for transactions they have been part of. Notice that the deployment transaction also<br>
appends a message to the creator u<sub>c</sub> of the chain-code, for the<br>
latter to be able to retrieve this transaction through parsing the ledger and without<br>
keeping any state locally.</p>
</li>
</ul>
<p>The entire transaction is signed by a certificate of the chaincode creator, i.e., enrollment<br>
or transaction certificate as decided by the latter.<br>
Two noteworthy points:</p>
<ul>
<li>Messages that are included in a transaction in an encrypted format, i.e., code-functions, code-hdrs,<br>
are signed before they are encrypted using the same TCert the entire transaction is signed with, or<br>
even with a different TCert or the ECert of the user (if the transaction deployment should carry the identity<br>
of its owner. A binding to the underlying transaction carrier should be included in the signed message, e.g.,<br>
the hash of the TCert the transaction is signed, such that mix&amp;match attacks are not possible.<br>
Though we detail such attacks in Section 4.4, in these cases an attacker who sees a transaction should not be able<br>
to isolate the ciphertext corresponding to, e.g., code-info, and use it for another transaction of her own.<br>
Clearly, such an ability would disrupt the operation of the system, as a chaincode that was first created by user A,<br>
will now also belong to malicious user B (who is not even able to read it).</li>
<li>To offer the ability to the users to cross-verify they are given access to the<br>
correct key, i.e., to the same key as the other contract users, transaction<br>
ciphertexts that are encrypted with a key K are accompanied by a commitment<br>
to K, while the opening of this commitment value is passed to all users who<br>
are entitled access to K in contract-users, and chain-validator sections.

In this way, anyone who is entitled access to that key can verify that the key<br>
has been properly passed to it. This part is omitted in the figure above to<br>
avoid confusion.</li>
</ul>
<p><strong>Structure of invoke transaction.</strong><br>
A transaction invoking the chain-code triggering the execution of a function of the chain-code with<br>
user-specified arguments is structured as depicted in the figure below.</p>
<p><a href="./images/sec-usrconf-invoke.png" target="_blank"><img src="./images/sec-usrconf-invoke.png" alt="FirstRelease-deploy" style="max-width:100%;"></a></p>
<p>Invocation transaction as in the case of deployment transaction consists of a<br>
<em>general-info</em> section, a <em>code-info</em> section, a section for the <em>chain-validators</em>,<br>
and one for the <em>contract users</em>, signed altogether with one of the invoker's<br>
transaction certificates.</p>
<ul>
<li>
<p>General-info follows the same structure as the corresponding section of the<br>
deployment transaction.<br>
The only difference relates to the transaction type that is now set to ''InvocTx'',<br>
and the chain-code identifier or name that is now encrypted under the<br>
chain-specific encryption (public) key.</p>
</li>
<li>
<p>Code-info exhibits the same structure as the one of the deployment transaction.<br>
Code payload, as in the case of deployment transaction, consists of function<br>
invocation details (the name of the function invoked, and associated arguments),<br>
code-metadata provided by the application and the transaction's creator<br>
(invoker's u) certificate, TCert<sub>u</sub>. Code payload is signed by the<br>
transaction certificate TCert<sub>u</sub> of the invoker u, as in the case<br>
of deploy transactions. As in the case of<br>
deploy transactions, code-metadata, and tx-metadata, are fields that are<br>
provided by the application and can be used (as described in Section 4.4),<br>
for the latter to implement their own access control mechanisms and roles.</p>
</li>
<li>
<p>Finally, contract-users and chain-validator sections provide the key the payload<br>
is encrypted with, the invoker's key, and the chain encryption key respectively.<br>
Upon receiving such transactions, the validators decrypt [code-name]<sub>PK<sub>chain</sub></sub> using the<br>
chain-specific secret key SK<sub>chain</sub> and obtain the invoked chain-code identifier.<br>
Given the latter, validators retrieve from their local storage the chaincode's<br>
decryption key SK<sub>c</sub>, and use it to decrypt chain-validators' message,<br>
that would equip them with the symmetric key K<sub>I</sub> the invocation<br>
transaction's payload was encrypted with.<br>
Given the latter, validators decrypt code-info, and execute the chain-code<br>
function with the specified arguments,<br>
and the code-metadata attached(See, Section 4.4 for more details on the use of<br>
code-metadata). While the chain-code is executed, updates of the state of that<br>
chain-code are possible.<br>
These are encrypted using the state-specific key K<sub>s</sub> that was defined<br>
during that chain-code's deployment. In particular, K<sub>s</sub> is used the<br>
same way K<sub>iTx</sub> is used in the design of our current release<br>
(See, Section 4.7).</p>
</li>
</ul>
<p><strong>Structure of query transaction.</strong><br>
Query transactions have the same format as invoke transactions.<br>
The only difference is that Query transactions do not affect the state<br>
of the chaincode, and thus there is no need for the state to be retrieved<br>
(decrypted) and/or updated (encrypted) after the execution of the chaincode<br>
completes.</p>
<h5>4.3.2.2 Confidentiality against validators</h5>
<p>This section deals with ways of how to support execution of certain transactions<br>
under a different (or subset) sets of validators in the current chain. This<br>
section inhibits IP restrictions and will be expanded in the following few weeks.</p>
<h4>4.3.3 Replay attack resistance</h4>
<p>In replay attacks the attacker "replays" a message it "eavesdropped" on the network or ''saw'' on the Blockchain.<br>
Replay attacks are a big problem here, as they can incur into the validating entities re-doing a computationally intensive<br>
process (chaincode invocation) and/or affect the state of the corresponding chaincode, while it requires minimal or no<br>
power from the attacker side. To make matters worse, if a transaction was a payment transaction, replays could<br>
potentially incur into the payment being performed more than once, without this being the original intention of the payer.<br>
Existing systems resist replay attacks as follows:</p>
<ul>
<li>Record hashes of transactions in the system. This solution would require that validators maintain a log of the hash of<br>
each transaction that has ever been announced through the network, and compare a new transaction against their locally<br>
stored transaction record. Clearly such approach cannot scale for large networks, and could easily result into validators<br>
spending a lot of time to do the check of whether a transaction has been replayed, than executing the actual transaction.</li>
<li>Leverage state that is maintained per user identity (Ethereum). Ethereum keeps some state, e.g., counter (initially set to 1)<br>
for each identity/pseudonym in the system. Users also maintain their own counter (initially set to 0) for each<br>
identity/pseudonym of theirs. Each time a user sends a transaction using an identity/pseudonym of his, he increases<br>
his local counter by one and adds the resulting value to the transaction. The transaction is subsequently signed by that<br>
user identity and released to the network. When picking up this transaction, validators check the counter value included<br>
within and compare it with the one they have stored locally; if the value is the same, they increase the local value of<br>
that identity's counter and accept the transaction. Otherwise, they reject the transaction as invalid or replay.<br>
Although this would work well in cases where we have limited number of user identities/pseudonyms (e.g., not too large),<br>
it would ultimately not scale in a system where users use a different identifier (transaction certificate) per transaction,<br>
and thus have a number of user pseudonyms proportional to the number of transactions.</li>
</ul>
<p>Other asset management systems, e.g., Bitcoin, though not directly dealing with replay attacks, they resist them. In systems<br>
that manage (digital) assets, state is maintained on a per asset basis, i.e., validators only keep a record of who owns what.<br>
Resistance to replay attacks come as a direct result from this, as replays of transactions would be immediately be<br>
deemed as invalid by the protocol (since can only be shown to be derived from older owners of an asset/coin). While this would<br>
be appropriate for asset management systems, this does not abide with the needs of a Blockchain systems with more generic<br>
use than asset management.</p>
<p>In the fabric, replay attack protection uses a hybrid approach.<br>
That is, users add in the transaction a nonce that is generated in a different manner<br>
depending on whether the transaction is anonymous (followed and signed by a transaction certificate) or not<br>
(followed and signed by a long term enrollment certificate). More specifically:</p>
<ul>
<li>
<p>Users submitting a transaction with their enrollment certificate should include in that<br>
transaction a nonce that is a function of the nonce they used in the previous transaction<br>
they issued with the same certificate (e.g., a counter function or a hash). The nonce included<br>
in the first transaction of each enrollment certificate can be either pre-fixed by the system<br>
(e.g., included in the genesis block) or chosen by the user. In the first case, the genesis block<br>
would need to include nonceall , i.e., a fixed number and the nonce used by user with identity<br>
IDA for his first enrollment certificate signed transaction would be</p>
nonce<sub>round<sub>0</sub>IDA</sub> &lt;- hash(IDA, nonce<sub>all</sub>),
where IDA appears in the enrollment certificate. From that point onward successive transactions of
that user with enrollment certificate would include a nonce as follows
nonce<sub>round<sub>i</sub>IDA</sub> &lt;- hash(nonce<sub>round<sub>{i-1}</sub>IDA</sub>),
that is the nonce of the ith transaction would be using the hash of the nonce used in the {i-1}th transaction of that certificate.
Validators here continue to process a transaction they receive, as long as it satisfies the condition mentioned above.
Upon successful validation of transaction's format, the validators update their database with that nonce.
<p><strong>Storage overhead</strong>:</p>
<ol>
<li>
<p>on the user side: only the most recently used nonce,</p>
</li>
<li>
<p>on validator side: O(n), where n is the number of users.</p>
</li>
</ol>
</li>
<li>
<p>Users submitting a transaction with a transaction certificate<br>
should include in the transaction a random nonce, that would guarantee that<br>
two transactions do not result into the same hash. Validators add the hash of<br>
this transaction in their local database if the transaction certificate used within<br>
it has not expired. To avoid storing large amounts of hashes, validity periods of transaction certificates<br>
are leveraged. In particular validators maintain an updated record of received<br>
transactions' hashes within the current or future validity period.</p>
<p><strong>Storage overhead</strong> (only makes sense for validators here):  O(m), where m is the approximate number of<br>
transactions within a validity period and corresponding validity period identifier (see below).</p>
</li>
</ul>
<h3>4.4 Access control features on the application</h3>
<p>An application, is a piece of software that runs on top of a Blockchain client software, and,<br>
performs a special task over the Blockchain, i.e., restaurant table reservation.<br>
Application software have a version of<br>
developer, enabling the latter to generate and manage a couple of chaincodes that are necessary for<br>
the business this application serves, and a client-version that would allow the application's end-users<br>
to make use of the application, by invoking these chain-codes.<br>
The use of the Blockchain can be transparent to the application end-users or not.</p>
<p>This section describes how an application leveraging chaincodes can implement its own access control policies,<br>
and guidelines on how our Membership services PKI can be leveraged for the same purpose.</p>
<p>The presentation is divided into enforcement of invocation access control,<br>
and enforcement of read-access control by the application.</p>
<h4>4.4.1 Invocation access control</h4>
<p>To allow the application to implement its own invocation access control at the<br>
application layer securely, special support by the fabric must be provided.<br>
In the following we elaborate on the tools exposed by the fabric to the<br>
application for this purpose, and provide guidelines on how these should be used<br>
by the application for the latter to enforce access control securely.</p>
<p><strong>Support from the infrastructure.</strong><br>
For the chaincode creator, let it be, <em>u<sub>c</sub></em>,<br>
to be able to implement its own invocation access control at<br>
the application layer securely, special support by the fabric must be provided.<br>
More specifically fabric layer gives access to following capabilities:</p>
<ol>
<li>
<p>The client-application can request the fabric to sign and verify any message with specific transaction certificates or enrollment certificate the client owns; this is expressed via the Certificate Handler interface</p>
</li>
<li>
<p>The client-application can request the fabric a unique <em>binding</em> to be used to bind authentication data of the application to the underlying transaction transporting it; this is expressed via the Transaction Handler interface</p>
</li>
<li>
<p>Support for a transaction format, that allows for the application to specify metadata, that are passed to the chain-code at deployment, and invocation time; the latter denoted by code-metadata.</p>
</li>
</ol>
<p>The <strong>Certificate Handler</strong> interface allows to sign and verify any message using signing key-pair underlying the associated certificate.<br>
The certificate can be a TCert or an ECert.</p>
<pre><code>// CertificateHandler exposes methods to deal with an ECert/TCert
type CertificateHandler interface {

    // GetCertificate returns the certificate's DER
    GetCertificate() []byte

    // Sign signs msg using the signing key corresponding to the certificate
    Sign(msg []byte) ([]byte, error)

    // Verify verifies msg using the verifying key corresponding to the certificate
    Verify(signature []byte, msg []byte) error

    // GetTransactionHandler returns a new transaction handler relative to this certificate
    GetTransactionHandler() (TransactionHandler, error)
}
</code></pre>
<p>The <strong>Transaction Handler</strong> interface allows to create transactions and give access to the underlying <em>binding</em> that can be leveraged to link<br>
application data to the underlying transaction. Bindings are a concept that have been introduced in network transport protocols (See, <a href="https://tools.ietf.org/html/rfc5056">https://tools.ietf.org/html/rfc5056</a>),<br>
known as <em>channel bindings</em>, that <em>allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer<br>
by binding authentication at the higher layer to the channel at the lower layer.<br>
This allows applications to delegate session protection to lower layers, which has various performance benefits.</em><br>
Transaction bindings offer the ability to uniquely identify the fabric layer of the transaction that serves as the container that<br>
application data uses to be added to the ledger.</p>
<pre><code>// TransactionHandler represents a single transaction that can be uniquely determined or identified by the output of the GetBinding method.
// This transaction is linked to a single Certificate (TCert or ECert).
type TransactionHandler interface {

    // GetCertificateHandler returns the certificate handler relative to the certificate mapped to this transaction
    GetCertificateHandler() (CertificateHandler, error)

    // GetBinding returns a binding to the underlying transaction (container)
    GetBinding() ([]byte, error)

    // NewChaincodeDeployTransaction is used to deploy chaincode
    NewChaincodeDeployTransaction(chaincodeDeploymentSpec *obc.ChaincodeDeploymentSpec, uuid string) (*obc.Transaction, error)

    // NewChaincodeExecute is used to execute chaincode's functions
    NewChaincodeExecute(chaincodeInvocation *obc.ChaincodeInvocationSpec, uuid string) (*obc.Transaction, error)

    // NewChaincodeQuery is used to query chaincode's functions
    NewChaincodeQuery(chaincodeInvocation *obc.ChaincodeInvocationSpec, uuid string) (*obc.Transaction, error)
}
</code></pre>
<p>For version 1, <em>binding</em> consists of the <em>hash</em>(TCert, Nonce), where TCert, is the transaction certificate<br>
used to sign the entire transaction, while Nonce, is the nonce number used within.</p>
<p>The <strong>Client</strong> interface is more generic, and offers a mean to get instances of the previous interfaces.</p>
<pre><code>type Client interface {

    ...

    // GetEnrollmentCertHandler returns a CertificateHandler whose certificate is the enrollment certificate
    GetEnrollmentCertificateHandler() (CertificateHandler, error)

    // GetTCertHandlerNext returns a CertificateHandler whose certificate is the next available TCert
    GetTCertificateHandlerNext() (CertificateHandler, error)

    // GetTCertHandlerFromDER returns a CertificateHandler whose certificate is the one passed
    GetTCertificateHandlerFromDER(der []byte) (CertificateHandler, error)

}
</code></pre>
<p>To support application-level access control lists for controlling chaincode<br>
invocation, the fabric's transaction and chaincode specification format<br>
have an additional field to store application-specific metadata.<br>
This field is depicted in both figures 1, by code-metadata. The content of this field is decided<br>
by the application, at the transaction creation time.<br>
The fabric layer treats it as an unstructured stream of bytes.</p>
<pre><code>
message ChaincodeSpec {

    ...

    ConfidentialityLevel confidentialityLevel;
    bytes metadata;

    ...
}


message Transaction {
    ...

    bytes payload;
    bytes metadata;

    ...
}
</code></pre>
<p>To assist chaincode execution, at the chain-code invocation time, the validators provide the<br>
chaincode with additional information, like the metadata and the binding.</p>
<p><strong>Application invocation access control.</strong><br>
This section describes how the application can leverage the means provided by the fabric<br>
to implement its own access control on its chain-code functions.<br>
In the scenario considered here, the following entities are identified:</p>
<ol>
<li>
<p><strong>C</strong>: is a chaincode that contains a single function, e.g., called <em>hello</em>;</p>
</li>
<li>
<p><strong>u<sub>c</sub></strong>: is the <strong>C</strong> deployer;</p>
</li>
<li>
<p><strong>u<sub>i</sub></strong>: is a user who is authorized to invoke <strong>C</strong>'s functions. User u<sub>c</sub> wants to ensure that only u<sub>i</sub> can invoke the function <em>hello</em>.</p>
</li>
</ol>
<p><em>Deployment of a Chaincode:</em> At deployment time, u<sub>c</sub> has full control on the deployment transaction's metadata,<br>
and can be used to store a list of ACLs (one per function), or a list of roles that are needed by the application. The format which is used to store these ACLs is up to the deployer's application, as the chain-code is the one<br>
who would need to parse the metadata at execution time.<br>
To define each of these lists/roles, u<sub>c</sub> can use any TCerts/Certs of the u<sub>i</sub> (or, if applicable, or other users who have been assigned that privilege or role). Let this be TCert<sub>u<sub>i</sub></sub>.<br>
The exchange of TCerts or Certs among the developer and authorized users is done through an out-of-band channel.</p>
<p>Assume that the application of u<sub>c</sub>'s requires that to invoke the <em>hello</em> function, a certain message <em>M</em> has to be authenticated by an authorized invoker (u<sub>i</sub>, in our example).<br>
One can distinguish the following two cases:</p>
<ol>
<li>
<p><em>M</em> is one of the chaincode's function arguments;</p>
</li>
<li>
<p><em>M</em> is the invocation message itself, i.e., function-name, function-arguments.</p>
</li>
</ol>
<p><em>Chaincode invocation:</em><br>
To invoke C, u<sub>i</sub>'s application needs to sign <em>M</em> using the TCert/ECert, that was used to identify u<sub>i</sub>'s participation in the chain-code at the associated<br>
deployment transaction's metadata, i.e., TCert<sub>u<sub>i</sub></sub>. More specifically, u<sub>i</sub>'s client application does the following:</p>
<ol>
<li>
<p>Retrieves a CertificateHandler for Cert<sub>u<sub>i</sub></sub>, <em>cHandler</em>;</p>
</li>
<li>
<p>obtains a new TransactionHandler to issue the execute transaction, <em>txHandler</em> relative to his next available TCert or his ECert;</p>
</li>
<li>
<p>gets <em>txHandler</em>'s <em>binding</em> by invoking <em>txHandler.getBinding()</em>;</p>
</li>
<li>
<p>signs <em>'<em>M</em> || txBinding'</em> by invoking <em>cHandler.Sign('<em>M</em> || txBinding')</em>, let <em>sigma</em> be the output of the signing function;</p>
</li>
<li>
<p>issues a new execute transaction by invoking, <em>txHandler.NewChaincodeExecute(...)</em>. Now, <em>sigma</em> can be included in the transaction as one of the arguments that are passed to the function (case 1) or as part of the code-metadata section of the payload(case 2).</p>
</li>
</ol>
<p><em>Chaincode processing:</em><br>
The validators, who receive the execute transaction issued u<sub>i</sub>, will provide to <em>hello</em> the following information:</p>
<ol>
<li>
<p>The <em>binding</em> of the execute transaction, that can be independently computed at the validator side;</p>
</li>
<li>
<p>The <em>metadata</em> of the execute transaction (code-metadata section of the transaction);</p>
</li>
<li>
<p>The <em>metadata</em> of the deploy transaction (code-metadata component of the corresponding deployment transaction).</p>
</li>
</ol>
<p>Notice that <em>sigma</em> is either part of the arguments of the invoked function, or stored inside the code-metadata of the invocation transaction (properly formatted by the client-application).<br>
Application ACLs are included in the code-metadata section, that is also passed to the chain-code at execution time.<br>
Function <em>hello</em> is responsible for checking that <em>sigma</em> is indeed a valid signature issued by TCert<sub>u<sub>i</sub></sub>, on '<em>M</em> || <em>txBinding'</em>.</p>
<h4>4.4.2 Read access control</h4>
<p>This section describes how the fabric's infrastructure offers support to the application to<br>
enforce its own read-access control policies at the level of users. As in the case of invocation access<br>
control, the first part describes the infrastructure features that can be leveraged by the application for this<br>
purpose, and the last part details on the way applications should use these tools.</p>
<p>For the purpose of this discussion, we leverage a similar example as before, i.e.,</p>
<ol>
<li>
<p><strong>C</strong>: is a chaincode that contains a single function, e.g., called <em>hello</em>;</p>
</li>
<li>
<p><strong>u<sub>A</sub></strong>: is the <strong>C</strong>'s deployer, also known as application;</p>
</li>
<li>
<p><strong>u<sub>r</sub></strong>: is a user who is authorized to read <strong>C</strong>'s functions. User u<sub>A</sub> wants to ensure that only u<sub>r</sub> can read the function <em>hello</em>.</p>
</li>
</ol>
<p><strong>Support from the infrastructure.</strong><br>
For <strong>u<sub>A</sub></strong> to be able to implement its own read access control at the application layer securely, our infrastructure is required to<br>
support the transaction format for code deployment and invocation, as depicted in the two figures below.</p>
<p><a href="./images/sec-usrconf-deploy-interm.png" target="_blank"><img src="./images/sec-usrconf-deploy-interm.png" alt="SecRelease-RACappDepl title=&quot;Deployment transaction format supporting application-level read access control.&quot;" style="max-width:100%;"></a></p>
<p><a href="./images/sec-usrconf-invoke-interm.png" target="_blank"><img src="./images/sec-usrconf-invoke-interm.png" alt="SecRelease-RACappInv title=&quot;Invocation transaction format supporting application-level read access control.&quot;" style="max-width:100%;"></a></p>
<p>More specifically fabric layer is required to provide the following functionality:</p>
<ol>
<li>
<p>Provide minimal encryption capability such that data is only decryptable by a validator's (infrastructure) side; this means that the infrastructure should move closer to our future version, where an asymmetric encryption scheme is used for encrypting transactions. More specifically, an asymmetric key-pair is used for the chain, denoted by K<sub>chain</sub> in the Figures above, but detailed in Section <a href="./txconf.md">Transaction Confidentiality</a>.</p>
</li>
<li>
<p>The client-application can request the infrastructure sitting on the client-side to encrypt/decrypt information using a specific public encryption key, or that client's long-term decryption key.</p>
</li>
<li>
<p>The transaction format offers the ability to the application to store additional transaction metadata, that can be passed to the client-application after the latter's request. Transaction metadata, as opposed to code-metadata, is not encrypted or provided to the chain-code at execution time. Validators treat these metadata as a list of bytes they are not responsible for checking validity of.</p>
</li>
</ol>
<p><strong>Application read-access control.</strong><br>
For this reason the application may request and obtain access to the public encryption key of the user <strong>u<sub>r</sub></strong>; let that be <strong>PK<sub>u<sub>r</sub></sub></strong>. Optionally,<br>
<strong>u<sub>r</sub></strong> may be providing <strong>u<sub>A</sub></strong> with a certificate of its, that would be leveraged by the application, say, TCert<sub>u<sub>r</sub></sub>; given the latter,<br>
the application would, e.g., be able to trace that user's transactions w.r.t. the application's chain-codes. TCert<sub>u<sub>r</sub></sub>, and PK<sub>u<sub>r</sub></sub>, are<br>
exchanged in an out-of-band channel.</p>
<p>At deployment time, application <strong>u<sub>A</sub></strong> performs the following steps:</p>
<ol>
<li>
<p>Uses the underlying infrastructure to encrypt the information of <strong>C</strong>, the application would like to make accessible to <strong>u<sub>r</sub></strong>, using PK<sub>u<sub>r</sub></sub>.<br>
Let C<sub>u<sub>r</sub></sub> be the resulting ciphertext.</p>
</li>
<li>
<p>(optional) C<sub>u<sub>r</sub></sub> can be concatenated with TCert<sub>u<sub>r</sub></sub></p>
</li>
<li>
<p>Passes the overall string as ''Tx-metadata'' of the confidential transaction to be constructed.</p>
</li>
</ol>
<p>At invocation time, the client-application on u<sub>r</sub>'s node, would be able, by obtaining the deployment transaction to retrieve the content of <strong>C</strong>.<br>
It just needs to retrieve the <strong>tx-metadata</strong> field of the associated deployment transaction, and trigger the decryption functionality offered by our Blockchain<br>
infrastrucure's client, for C<sub>u<sub>r</sub></sub>. Notice that it is the application's responsibility to encrypt the correct <strong>C</strong> for u<sub>r</sub>.<br>
Also, the use of <strong>tx-metadata</strong> field can be generalized to accommodate application-needs. E.g., it can be that invokers leverage the same field of invocation transactions<br>
to pass information to the developer of the application, etc.</p>
<p><strong>Important Note:</strong>  It is essential to note that validators <strong>do not provide</strong> any decryption oracle to the chain-code<br>
throughout its execution. Its infrastructure is though responsible for decrypting the payload of the chain-code itself (as well as<br>
the code-metadata fields near it), and provide those to containers for deployment/execution.</p>
<h3>4.5 Online wallet service</h3>
<p>This section describes the security design of a wallet service, which in this case is a node with which end-users can register, store their key material and through which they can perform transactions.<br>
Because the wallet service is in possession of the user's key material, it is clear that without a secure authorization<br>
mechanism in place a malicious wallet service could successfully impersonate the user.<br>
We thus emphasize that this design corresponds to a wallet service that is <strong>trusted</strong> to only perform transactions<br>
on behalf of its clients, with the consent of the latter.<br>
There are two cases for the registration of an end-user to an online wallet service:</p>
<ol>
<li>When the user has registered with the registration authority and acquired his/her <code>&lt;enrollID, enrollPWD&gt;</code>,<br>
but has not installed the client to trigger and complete the enrollment process;</li>
<li>When the user has already installed the client, and completed the enrollment phase.</li>
</ol>
<p>Initially, the user interacts with the online wallet service to issue credentials that would allow him to authenticate<br>
to the wallet service. That is, the user is given a username, and password, where username identifies the user in the<br>
membership service, denoted by AccPub, and password is the associated secret, denoted by AccSec, that is <strong>shared</strong> by<br>
both user and service.</p>
<p>To enroll through the online wallet service, a user must provide the following request<br>
object to the wallet service:</p>
<pre><code>AccountRequest /* account request of u \*/
{
    OBCSecCtx ,           /* credentials associated to network \*/
    AccPub&lt;sub&gt;u&lt;/sub&gt;,   /* account identifier of u \*/
    AccSecProof&lt;sub&gt;u&lt;/sub&gt;  /* proof of AccSec&lt;sub&gt;u&lt;/sub&gt;\*/
 }
</code></pre>
<p>OBCSecCtx refers to user credentials, which depending on the stage of his enrollment process, can be either his enrollment ID and password, <code>&lt;enrollID, enrollPWD&gt;</code> or his enrollment certificate and associated secret key(s)<br>
(ECert<sub>u</sub>, sk<sub>u</sub>),  where  sk<sub>u</sub> denotes for simplicity signing and decryption secret of the user.<br>
The content of AccSecProof<sub>u</sub> is an HMAC on the rest fields of request using the shared secret. Nonce-based methods<br>
similar to what we have in the fabric can be used to protect against replays.<br>
OBCSecCtx would give the online wallet service the necessary information to enroll the user or issue required TCerts.</p>
<p>For subsequent requests, the user u should provide to the wallet service a request of similar format.</p>
<pre><code> TransactionRequest /* account request of u \*/
 {
      TxDetails,			/* specifications for the new transaction \*/
      AccPub&lt;sub&gt;u&lt;/sub&gt;,		/* account identifier of u \*/
      AccSecProof&lt;sub&gt;u&lt;/sub&gt;	/* proof of AccSec&lt;sub&gt;u&lt;/sub&gt; \*/
 }
</code></pre>
<p>Here, TxDetails refer to the information needed by the online service to construct a transaction on behalf of the user, i.e.,<br>
the type, and user-specified content of the transaction.</p>
<p>AccSecProof<sub>u</sub> is again an HMAC on the rest fields of request using the shared secret.<br>
Nonce-based methods similar to what we have in the fabric can be used to protect against replays.</p>
<p>TLS connections can be used in each case with server side authentication to secure the request at the<br>
network layer (confidentiality, replay attack protection, etc)</p>
<h3>4.6 Network security (TLS)</h3>
<p>The TLS CA should be capable of issuing TLS certificates to (non-validating) peers, validators, and individual clients (or browsers capable of storing a private key). Preferably, these certificates are distinguished by type, per above. TLS certificates for CAs of the various types (such as TLS CA, ECA, TCA) could be issued by an intermediate CA (i.e., a CA that is subordinate to the root CA). Where there is not a particular traffic analysis issue, any given TLS connection can be mutually authenticated, except for requests to the TLS CA for TLS certificates.</p>
<p>In the current implementation the only trust anchor is the TLS CA self-signed certificate in order to accommodate the limitation of a single port to communicate with all three (co-located) servers, i.e., the TLS CA, the TCA and the ECA. Consequently, the TLS handshake is established with the TLS CA, which passes the resultant session keys to the co-located TCA and ECA. The trust in validity of the TCA and ECA self-signed certificates is therefore inherited from trust in the TLS CA. In an implementation that does not thus elevate the TLS CA above other CAs, the trust anchor should be replaced with a root CA under which the TLS CA and all other CAs are certified.</p>
<h3>4.7 Restrictions in the current release</h3>
<p>This section lists the restrictions of the current release of the fabric.<br>
A particular focus is given on client operations and the design of transaction confidentiality,<br>
as depicted in Sections 4.7.1 and 4.7.2.</p>
<ul>
<li>Client side enrollment and transaction creation is performed entirely by a<br>
non-validating peer that is trusted not to impersonate the user.<br>
See, Section 4.7.1 for more information.</li>
<li>A minimal set of confidentiality properties where a chaincode is accessible<br>
by any entity that is member of the system, i.e., validators and users who<br>
have registered through Hyperledger Fabric's Membership Services and is not accessible by anyone else.<br>
The latter include any party that has access to the storage area where the<br>
ledger is maintained, or other entities that are able to see the transactions<br>
that are announced in the validator network. The design of the first release<br>
is detailed in subsection 4.7.2</li>
<li>The code utilizes self-signed certificates for entities such as the<br>
enrollment CA (ECA) and the transaction CA (TCA)</li>
<li>Replay attack resistance mechanism is not available</li>
<li>Invocation access control can be enforced at the application layer:<br>
it is up to the application to leverage the infrastructure's tools properly<br>
for security to be guaranteed. This means, that if the application fails to<br>
<em>bind</em> the transaction binding offered by the fabric, secure transaction<br>
processing may be at risk.</li>
</ul>
<h4>4.7.1 Simplified client</h4>
<p>Client-side enrollment and transaction creation are performed entirely by a non-validating peer that plays the role of an online wallet.<br>
In particular, the end-user leverages their registration credentials &lt;username, password&gt; to open an account to a non-validating peer<br>
and uses these credentials to further authorize the peer to build transactions on the user's behalf. It needs to be noted, that such<br>
a design does not provide secure <strong>authorization</strong> for the peer to submit transactions on behalf of the user, as a malicious peer<br>
could impersonate the user. Details on the specifications of a design that deals with the security issues of online wallet can be found is Section 4.5.<br>
Currently the maximum number of peers a user can register to and perform transactions through is one.</p>
<h4>4.7.2 Simplified transaction confidentiality</h4>
<p><strong>Disclaimer:</strong> The current version of transaction confidentiality is minimal, and will be used as an intermediate step<br>
to reach a design that allows for fine grained (invocation) access control enforcement in a subsequent release.</p>
<p>In its current form, confidentiality of transactions is offered solely at the chain-level, i.e., that the<br>
content of a transaction included in a ledger, is readable by all members of that chain, i.e., validators<br>
and users. At the same time, application auditors who are not members of the system can be given<br>
the means to perform auditing by passively observing the blockchain data, while<br>
guaranteeing that they are given access solely to the transactions related to the application under audit.<br>
State is encrypted in a way that such auditing requirements are satisfied, while not disrupting the<br>
proper operation of the underlying consensus network.</p>
<p>More specifically, currently symmetric key encryption is supported in the process of offering transaction confidentiality. In this setting, one of the main challenges that is specific to the blockchain setting,<br>
is that validators need to run consensus over the state of the blockchain, that, aside from the transactions themselves,<br>
also includes the state updates of individual contracts or chaincode. Though this is trivial to do for non-confidential chaincode, for confidential chaincode, one needs to design the state encryption mechanism such that the resulting ciphertexts are semantically secure, and yet, identical if the plaintext state is the same.</p>
<p>To overcome this challenge, the fabric utilizes a key hierarchy that reduces the number of ciphertexts<br>
that are encrypted under the same key. At the same time, as some of these keys are used for the generation of IVs,<br>
this allows the validating parties to generate exactly the same ciphertext when executing the same transaction<br>
(this is necessary to remain agnostic to the underlying consensus algorithm) and offers the possibility of controlling audit by disclosing to auditing entities only the most relevant keys.</p>
<p><strong>Method description:</strong><br>
Membership service generates a symmetric key for the ledger (K<sub>chain</sub>) that is distributed<br>
at registration time to all the entities of the blockchain system, i.e., the clients and the<br>
validating entities that have issued credentials through the membership service of the chain.<br>
At enrollment phase, user obtain (as before) an enrollment certificate, denoted by Cert<sub>u<sub>i</sub></sub><br>
for user u<sub>i</sub> , while each validator v<sub>j</sub> obtains its enrollment certificate denoted by Cert<sub>v<sub>j</sub></sub>.</p>
<p>Entity enrollment would be enhanced, as follows. In addition to enrollment certificates,<br>
users who wish to anonymously participate in transactions issue transaction certificates.<br>
For simplicity transaction certificates of a user u<sub>i</sub> are denoted by TCert<sub>u<sub>i</sub></sub>.<br>
Transaction certificates include the public part of a signature key-pair denoted by (tpk<sub>u<sub>i</sub></sub>,tsk<sub>u<sub>i</sub></sub>).</p>
<p>In order to defeat crypto-analysis and enforce confidentiality, the following key hierarchy is considered for generation and validation of confidential transactions:<br>
To submit a confidential transaction (Tx) to the ledger, a client first samples a nonce (N), which is required to be unique among all the transactions submitted to the blockchain, and derive a transaction symmetric<br>
key (K<sub>Tx</sub>) by applying the HMAC function keyed with K<sub>chain</sub> and on input the nonce, K<sub>Tx</sub>= HMAC(K<sub>chain</sub>, N). From K<sub>Tx</sub>, the client derives two AES keys:<br>
K<sub>TxCID</sub> as HMAC(K<sub>Tx</sub>, c<sub>1</sub>), K<sub>TxP</sub> as HMAC(K<sub>Tx</sub>, c<sub>2</sub>)) to encrypt respectively the chain-code name or identifier CID and code (or payload) P.<br>
c<sub>1</sub>, c<sub>2</sub> are public constants. The nonce, the Encrypted Chaincode ID (ECID) and the Encrypted Payload (EP) are added in the transaction Tx structure, that is finally signed and so<br>
authenticated. Figure below shows how encryption keys for the client's transaction are generated. Arrows in this figure denote application of an HMAC, keyed by the key at the source of the arrow and<br>
using the number in the arrow as argument. Deployment/Invocation transactions' keys are indicated by d/i respectively.</p>
<p><a href="./images/sec-firstrel-1.png" target="_blank"><img src="./images/sec-firstrel-1.png" alt="FirstRelease-clientSide" style="max-width:100%;"></a></p>
<p>To validate a confidential transaction Tx submitted to the blockchain by a client,<br>
a validating entity first decrypts ECID and EP by re-deriving K<sub>TxCID</sub> and K<sub>TxP</sub><br>
from K<sub>chain</sub> and Tx.Nonce as done before. Once the Chaincode ID and the<br>
Payload are recovered the transaction can be processed.</p>
<p><a href="./images/sec-firstrel-2.png" target="_blank"><img src="./images/sec-firstrel-2.png" alt="FirstRelease-validatorSide" style="max-width:100%;"></a></p>
<p>When V validates a confidential transaction, the corresponding chaincode can access and modify the<br>
chaincode's state. V keeps the chaincode's state encrypted. In order to do so, V generates symmetric<br>
keys as depicted in the figure above. Let iTx be a confidential transaction invoking a function<br>
deployed at an early stage by the confidential transaction dTx (notice that iTx can be dTx itself<br>
in the case, for example, that dTx has a setup function that initializes the chaincode's state).<br>
Then, V generates two symmetric keys  K<sub>IV</sub>  and K<sub>state</sub> as follows:</p>
<ol>
<li>It computes  as  K<sub>dTx</sub> , i.e., the transaction key of the corresponding deployment<br>
transaction, and then N<sub>state</sub> = HMAC(K<sub>dtx</sub> ,hash(N<sub>i</sub>)), where N<sub>i</sub><br>
is the nonce appearing in the invocation transaction, and <em>hash</em> a hash function.</li>
<li>It sets K<sub>state</sub> = HMAC(K<sub>dTx</sub>, c<sub>3</sub> || N<sub>state</sub>),<br>
truncated opportunely deeding on the underlying cipher used to encrypt; c<sub>3</sub> is a constant number</li>
<li>It sets K<sub>IV</sub> = HMAC(K<sub>dTx</sub>, c<sub>4</sub> || N<sub>state</sub>); c<sub>4</sub> is a constant number</li>
</ol>
<p>In order to encrypt a state variable S, a validator first generates the IV as HMAC(K<sub>IV</sub>, crt<sub>state</sub>)<br>
properly truncated, where crt<sub>state</sub> is a counter value that increases each time a state update<br>
is requested for the same chaincode invocation. The counter is discarded after the execution of<br>
the chaincode terminates. After IV has been generated, V encrypts with authentication (i.e., GSM mode)<br>
the value of S concatenated with Nstate(Actually, N<sub>state</sub>  doesn't need to be encrypted but<br>
only authenticated). To the resulting ciphertext (CT), N<sub>state</sub> and the IV used is appended.<br>
In order to decrypt an encrypted state CT|| N<sub>state'</sub> , a validator first generates the symmetric<br>
keys K<sub>dTX</sub>' ,K<sub>state</sub>' using N<sub>state'</sub> and then decrypts CT.</p>
<p>Generation of IVs: In order to be agnostic to any underlying consensus algorithm, all the validating<br>
parties need a method to produce the same exact ciphertexts. In order to do so, the validators need<br>
to use the same IVs. Reusing the same IV with the same symmetric key completely breaks the security<br>
of the underlying cipher. Therefore, the process described before is followed. In particular, V first<br>
derives an IV generation key K<sub>IV</sub> by computing HMAC(K<sub>dTX</sub>, c<sub>4</sub> || N<sub>state</sub> ),<br>
where c<sub>4</sub> is a constant number, and keeps a counter crt<sub>state</sub> for the pair<br>
(dTx, iTx) with is initially set to 0. Then, each time a new ciphertext has to be generated, the validator<br>
generates a new IV by computing it as the output of HMAC(K<sub>IV</sub>, crt<sub>state</sub>)<br>
and then increments the crt<sub>state</sub> by one.</p>
<p>Another benefit that comes with the above key hierarchy is the ability to enable controlled auditing.<br>
For example, while by releasing K<sub>chain</sub> one would provide read access to the whole chain,<br>
by releasing only K<sub>state</sub> for a given pair of transactions (dTx,iTx) access would be granted to a state<br>
updated by iTx, and so on.</p>
<p>The following figures demonstrate the format of a deployment and invocation transaction currently available in the code.</p>
<p><a href="./images/sec-firstrel-depl.png" target="_blank"><img src="./images/sec-firstrel-depl.png" alt="FirstRelease-deploy" style="max-width:100%;"></a></p>
<p><a href="./images/sec-firstrel-inv.png" target="_blank"><img src="./images/sec-firstrel-inv.png" alt="FirstRelease-deploy" style="max-width:100%;"></a></p>
<p>One can notice that both deployment and invocation transactions consist of two sections:</p>
<ul>
<li>
<p>Section <em>general-info</em>: contains the administration details of the transaction, i.e., which chain this transaction corresponds to (is chained to), the type of transaction (that is set to ''deploymTx'' or ''invocTx''), the version number of confidentiality policy implemented, its creator identifier (expressed by means of TCert of Cert) and a nonce (facilitates primarily replay-attack resistance techniques).</p>
</li>
<li>
<p>Section <em>code-info</em>: contains information on the chain-code source code. For deployment transaction this is essentially the chain-code identifier/name and source code, while for invocation chain-code is the name of the function invoked and its arguments. As shown in the two figures code-info in both transactions are encrypted ultimately using the chain-specific symmetric key K<sub>chain</sub>.</p>
</li>
</ul>
<h2>5. Byzantine Consensus</h2>
<p>The <code>pbft</code> package is an implementation of the seminal <a href="http://dl.acm.org/citation.cfm?id=571640" title="PBFT">PBFT</a> consensus protocol [1], which provides consensus among validators despite a threshold of validators acting as <em>Byzantine</em>, i.e., being malicious or failing in an unpredictable manner. In the default configuration, PBFT tolerates up to t&lt;n/3 Byzantine validators.</p>
<p>In the default configuration, PBFT is designed to run on at least <em>3t+1</em> validators (replicas), tolerating up to <em>t</em> potentially faulty (including malicious, or <em>Byzantine</em>) replicas.</p>
<h3>5.1 Overview</h3>
<p>The <code>pbft</code> plugin provides an implementation of the PBFT consensus protocol.</p>
<h3>5.2 Core PBFT Functions</h3>
<p>The following functions control for parallelism using a non-recursive lock and can therefore be invoked from multiple threads in parallel. However, the functions typically run to completion and may invoke functions from the CPI passed in. Care must be taken to prevent livelocks.</p>
<h4>5.2.1 newPbftCore</h4>
<p>Signature:</p>
<pre><code>func newPbftCore(id uint64, config *viper.Viper, consumer innerCPI, ledger consensus.Ledger) *pbftCore
</code></pre>
<p>The <code>newPbftCore</code> constructor instantiates a new PBFT box instance, with the specified <code>id</code>. The <code>config</code> argument defines operating parameters of the PBFT network: number replicas <em>N</em>, checkpoint period <em>K</em>, and the timeouts for request completion and view change duration.</p>
<table>
<thead>
<tr>
<th>configuration key</th>
<th>type</th>
<th>example value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>general.N</code></td>
<td><em>integer</em></td>
<td>4</td>
<td>Number of replicas</td>
</tr>
<tr>
<td><code>general.K</code></td>
<td><em>integer</em></td>
<td>10</td>
<td>Checkpoint period</td>
</tr>
<tr>
<td><code>general.timeout.request</code></td>
<td><em>duration</em></td>
<td>2s</td>
<td>Max delay between request reception and execution</td>
</tr>
<tr>
<td><code>general.timeout.viewchange</code></td>
<td><em>duration</em></td>
<td>2s</td>
<td>Max delay between view-change start and next request execution</td>
</tr></tbody></table>
<p>The arguments <code>consumer</code> and <code>ledger</code> pass in interfaces that are used<br>
to query the application state and invoke application requests once<br>
they have been totally ordered. See the respective sections below for<br>
these interfaces.</p>
<h2>6. Application Programming Interface</h2>
<p>The primary interface to the fabric is a REST API. The REST API allows applications to register users, query the blockchain, and to issue transactions. A CLI is also provided to cover a subset of the available APIs for development purposes. The CLI enables developers to quickly test chaincodes or query for status of transactions.</p>
<p>Applications interact with a non-validating peer node through the REST API, which will require some form of authentication to ensure the entity has proper privileges. The application is responsible for implementing the appropriate authentication mechanism and the peer node will subsequently sign the outgoing messages with the client identity.</p>
<p><a href="images/refarch-api.png" target="_blank"><img src="images/refarch-api.png" alt="Reference architecture" style="max-width:100%;"></a> </p><p><br>
The fabric API design covers the categories below, though the implementation is incomplete for some of them in the current release. The <a href="#62-rest-api">REST API</a> section will describe the APIs currently supported.</p>
<ul>
<li>Identity - Enrollment to acquire or to revoke a certificate</li>
<li>Address - Target and source of a transaction</li>
<li>Transaction - Unit of execution on the ledger</li>
<li>Chaincode - Program running on the ledger</li>
<li>Blockchain - Contents of the ledger</li>
<li>Network - Information about the blockchain peer network</li>
<li>Storage - External store for files or documents</li>
<li>Event Stream - Sub/pub events on the blockchain</li>
</ul>
<h3>6.1 REST Service</h3>
<p>The REST service can be enabled (via configuration) on either validating or non-validating peers, but it is recommended to only enable the REST service on non-validating peers on production networks.</p>
<pre><code>func StartOpenchainRESTServer(server *oc.ServerOpenchain, devops *oc.Devops)
</code></pre>
<p>This function reads the <code>rest.address</code> value in the <code>core.yaml</code> configuration file, which is the configuration file for the <code>peer</code> process. The value of the <code>rest.address</code> key defines the default address and port on which the peer will listen for HTTP REST requests.</p>
<p>It is assumed that the REST service receives requests from applications which have already authenticated the end user.</p>
<h3>6.2 REST API</h3>
<p>You can work with the REST API through any tool of your choice. For example, the curl command line utility or a browser based client such as the Firefox Rest Client or Chrome Postman. You can likewise trigger REST requests directly through <a href="http://swagger.io/">Swagger</a>. To obtain the REST API Swagger description, click <a href="https://github.com/hyperledger/fabric/blob/master/core/rest/rest_api.json">here</a>. The currently available APIs are summarized in the following section.</p>
<h4>6.2.1 REST Endpoints</h4>
<ul>
<li><a href="#6211-block-api">Block</a>
<ul>
<li>GET /chain/blocks/{block-id}</li>
</ul>
</li>
<li><a href="#6212-blockchain-api">Blockchain</a>
<ul>
<li>GET /chain</li>
</ul>
</li>
<li><a href="#6213-chaincode-api">Chaincode</a>
<ul>
<li>POST /chaincode</li>
</ul>
</li>
<li><a href="#6214-network-api">Network</a>
<ul>
<li>GET /network/peers</li>
</ul>
</li>
<li><a href="#6215-registrar-api-member-services">Registrar</a>
<ul>
<li>POST /registrar</li>
<li>GET /registrar/{enrollmentID}</li>
<li>DELETE /registrar/{enrollmentID}</li>
<li>GET /registrar/{enrollmentID}/ecert</li>
<li>GET /registrar/{enrollmentID}/tcert</li>
</ul>
</li>
<li><a href="#6216-transactions-api">Transactions</a>
<ul>
<li>GET /transactions/{UUID}</li>
</ul>
</li>
</ul>
<h5>6.2.1.1 Block API</h5>
<ul>
<li><strong>GET /chain/blocks/{block-id}</strong></li>
</ul>
<p>Use the Block API to retrieve the contents of various blocks from the blockchain. The returned Block message structure is defined in section <a href="#3211-block">3.2.1.1</a>.</p>
<p>Block Retrieval Request:</p>
<pre><code>GET host:port/chain/blocks/173
</code></pre>
<p>Block Retrieval Response:</p>
<pre><code>{
    "transactions": [
        {
            "type": 3,
            "chaincodeID": "EgRteWNj",
            "payload": "Ch4IARIGEgRteWNjGhIKBmludm9rZRIBYRIBYhICMTA=",
            "uuid": "f5978e82-6d8c-47d1-adec-f18b794f570e",
            "timestamp": {
                "seconds": 1453758316,
                "nanos": 206716775
            },
            "cert": "MIIB/zCCAYWgAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMTI1MjE0MTE3WhcNMTYwNDI0MjE0MTE3WjArMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQ4wDAYDVQQDEwVsdWthczB2MBAGByqGSM49AgEGBSuBBAAiA2IABC/BBkt8izf6Ew8UDd62EdWFikJhyCPY5VO9Wxq9JVzt3D6nubx2jO5JdfWt49q8V1Aythia50MZEDpmKhtM6z7LHOU1RxuxdjcYDOvkNJo6pX144U4N1J8/D3A+97qZpKN/MH0wDgYDVR0PAQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwDQYDVR0OBAYEBAECAwQwDwYDVR0jBAgwBoAEAQIDBDA9BgYqAwQFBgcBAf8EMABNbPHZ0e/2EToi0H8mkouuUDwurgBYuUB+vZfeMewBre3wXG0irzMtfwHlfECRDDAKBggqhkjOPQQDAwNoADBlAjAoote5zYFv91lHzpbEwTfJL/+r+CG7oMVFUFuoSlvBSCObK2bDIbNkW4VQ+ZC9GTsCMQC5GCgy2oZdHw/x7XYzG2BiqmRkLRTiCS7vYCVJXLivU65P984HopxW0cEqeFM9co0=",
            "signature": "MGUCMCIJaCT3YRsjXt4TzwfmD9hg9pxYnV13kWgf7e1hAW5Nar//05kFtpVlq83X+YtcmAIxAK0IQlCgS6nqQzZEGCLd9r7cg1AkQOT/RgoWB8zcaVjh3bCmgYHsoPAPgMsi3TJktg=="
        }
    ],
    "stateHash": "7ftCvPeHIpsvSavxUoZM0u7o67MPU81ImOJIO7ZdMoH2mjnAaAAafYy9MIH3HjrWM1/Zla/Q6LsLzIjuYdYdlQ==",
    "previousBlockHash": "lT0InRg4Cvk4cKykWpCRKWDZ9YNYMzuHdUzsaeTeAcH3HdfriLEcTuxrFJ76W4jrWVvTBdI1etxuIV9AO6UF4Q==",
    "nonHashData": {
        "localLedgerCommitTimestamp": {
            "seconds": 1453758316,
            "nanos": 250834782
        }
    }
}
</code></pre>
<h5>6.2.1.2 Blockchain API</h5>
<ul>
<li><strong>GET /chain</strong></li>
</ul>
<p>Use the Chain API to retrieve the current state of the blockchain. The returned BlockchainInfo message is defined below.</p>
<pre><code>message BlockchainInfo {
    uint64 height = 1;
    bytes currentBlockHash = 2;
    bytes previousBlockHash = 3;
}
</code></pre>
<ul>
<li>
<p><code>height</code> - Number of blocks in the blockchain, including the genesis block.</p>
</li>
<li>
<p><code>currentBlockHash</code> - The hash of the current or last block.</p>
</li>
<li>
<p><code>previousBlockHash</code> - The hash of the previous block.</p>
</li>
</ul>
<p>Blockchain Retrieval Request:</p>
<pre><code>GET host:port/chain
</code></pre>
<p>Blockchain Retrieval Response:</p>
<pre><code>{
    "height": 174,
    "currentBlockHash": "lIfbDax2NZMU3rG3cDR11OGicPLp1yebIkia33Zte9AnfqvffK6tsHRyKwsw0hZFZkCGIa9wHVkOGyFTcFxM5w==",
    "previousBlockHash": "Vlz6Dv5OSy0OZpJvijrU1cmY2cNS5Ar3xX5DxAi/seaHHRPdssrljDeppDLzGx6ZVyayt8Ru6jO+E68IwMrXLQ=="
}
</code></pre>
<h5>6.2.1.3 Chaincode API</h5>
<ul>
<li><strong>POST /chaincode</strong></li>
</ul>
<p>Use the Chaincode API to deploy, invoke, and query chaincodes. The deploy request requires the client to supply a <code>path</code> parameter, pointing to the directory containing the chaincode in the file system. The response to a deploy request is either a message containing a confirmation of successful chaincode deployment or an error, containing a reason for the failure. It also contains the generated chaincode <code>name</code> in the <code>message</code> field, which is to be used in subsequent invocation and query transactions to uniquely identify the deployed chaincode.</p>
<p>To deploy a chaincode, supply the required ChaincodeSpec payload, defined in section <a href="#3122-transaction-specification">3.1.2.2</a>.</p>
<p>Deploy Request:</p>
<pre><code>POST host:port/chaincode

{
  "jsonrpc": "2.0",
  "method": "deploy",
  "params": {
    "type": "GOLANG",
    "chaincodeID":{
        "path":"github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02"
    },
    "input": {
        "function":"init",
        "args":["a", "1000", "b", "2000"]
    }
  },
  "id": "1"  
}
</code></pre>
<p>Deploy Response:</p>
<pre><code>{
    "jsonrpc": "2.0",
    "result": {
        "status": "OK",
        "message": "52b0d803fc395b5e34d8d4a7cd69fb6aa00099b8fabed83504ac1c5d61a425aca5b3ad3bf96643ea4fdaac132c417c37b00f88fa800de7ece387d008a76d3586"
    },
    "id": 1
}
</code></pre>
<p>With security enabled, modify the required payload to include the <code>secureContext</code> element passing the enrollment ID of a logged in user as follows:</p>
<p>Deploy Request with security enabled:</p>
<pre><code>POST host:port/chaincode

{
  "jsonrpc": "2.0",
  "method": "deploy",
  "params": {
    "type": "GOLANG",
    "chaincodeID":{
        "path":"github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02"
    },
    "input": {
        "function":"init",
        "args":["a", "1000", "b", "2000"]
    },
    "secureContext": "lukas"
  },
  "id": "1"  
}
</code></pre>
<p>The invoke request requires the client to supply a <code>name</code> parameter, which was previously returned in the response from the deploy transaction. The response to an invocation request is either a message containing a confirmation of successful execution or an error, containing a reason for the failure.</p>
<p>To invoke a function within a chaincode, supply the required ChaincodeSpec payload, defined in section <a href="#3122-transaction-specification">3.1.2.2</a>.</p>
<p>Invoke Request:</p>
<pre><code>POST host:port/chaincode

{
  "jsonrpc": "2.0",
  "method": "invoke",
  "params": {
  	"type": "GOLANG",
    "chaincodeID":{
      "name":"52b0d803fc395b5e34d8d4a7cd69fb6aa00099b8fabed83504ac1c5d61a425aca5b3ad3bf96643ea4fdaac132c417c37b00f88fa800de7ece387d008a76d3586"
    },
  	"input": {
    	"function":"invoke",
      	"args":["a", "b", "100"]
  	}
  },
  "id": "3"  
}
</code></pre>
<p>Invoke Response:</p>
<pre><code>{
    "jsonrpc": "2.0",
    "result": {
        "status": "OK",
        "message": "5a4540e5-902b-422d-a6ab-e70ab36a2e6d"
    },
    "id": 3
}
</code></pre>
<p>With security enabled, modify the required payload to include the <code>secureContext</code> element passing the enrollment ID of a logged in user as follows:</p>
<p>Invoke Request with security enabled:</p>
<pre><code>{
  "jsonrpc": "2.0",
  "method": "invoke",
  "params": {
  	"type": "GOLANG",
    "chaincodeID":{
      "name":"52b0d803fc395b5e34d8d4a7cd69fb6aa00099b8fabed83504ac1c5d61a425aca5b3ad3bf96643ea4fdaac132c417c37b00f88fa800de7ece387d008a76d3586"
    },
  	"input": {
    	"function":"invoke",
      	"args":["a", "b", "100"]
  	},
  	"secureContext": "lukas"
  },
  "id": "3"  
}
</code></pre>
<p>The query request requires the client to supply a <code>name</code> parameter, which was previously returned in the response from the deploy transaction. The response to a query request depends on the chaincode implementation. The response will contain a message containing a confirmation of successful execution or an error, containing a reason for the failure. In the case of successful execution, the response will also contain values of requested state variables within the chaincode.</p>
<p>To invoke a query function within a chaincode, supply the required ChaincodeSpec payload, defined in section <a href="#3122-transaction-specification">3.1.2.2</a>.</p>
<p>Query Request:</p>
<pre><code>POST host:port/chaincode/

{
  "jsonrpc": "2.0",
  "method": "query",
  "params": {
  	"type": "GOLANG",
    "chaincodeID":{
      "name":"52b0d803fc395b5e34d8d4a7cd69fb6aa00099b8fabed83504ac1c5d61a425aca5b3ad3bf96643ea4fdaac132c417c37b00f88fa800de7ece387d008a76d3586"
    },
  	"input": {
    	"function":"query",
      	"args":["a"]
  	}
  },
  "id": "5"  
}
</code></pre>
<p>Query Response:</p>
<pre><code>{
    "jsonrpc": "2.0",
    "result": {
        "status": "OK",
        "message": "-400"
    },
    "id": 5
}
</code></pre>
<p>With security enabled, modify the required payload to include the <code>secureContext</code> element passing the enrollment ID of a logged in user as follows:</p>
<p>Query Request with security enabled:</p>
<pre><code>{
  "jsonrpc": "2.0",
  "method": "query",
  "params": {
  	"type": "GOLANG",
    "chaincodeID":{
      "name":"52b0d803fc395b5e34d8d4a7cd69fb6aa00099b8fabed83504ac1c5d61a425aca5b3ad3bf96643ea4fdaac132c417c37b00f88fa800de7ece387d008a76d3586"
    },
  	"input": {
    	"function":"query",
      	"args":["a"]
  	},
  	"secureContext": "lukas"
  },
  "id": "5"  
}
</code></pre>
<h5>6.2.1.4 Network API</h5>
<p>Use the Network API to retrieve information about the network of peer nodes comprising the blockchain fabric.</p>
<p>The /network/peers endpoint returns a list of all existing network connections for the target peer node. The list includes both validating and non-validating peers. The list of peers is returned as type <code>PeersMessage</code>, containing an array of <code>PeerEndpoint</code>, defined in section <a href="#311-discovery-messages">3.1.1</a>.</p>
<pre><code>message PeersMessage {
    repeated PeerEndpoint peers = 1;
}
</code></pre>
<p>Network Request:</p>
<pre><code>GET host:port/network/peers
</code></pre>
<p>Network Response:</p>
<pre><code>{
    "peers": [
        {
            "ID": {
                "name": "vp1"
            },
            "address": "172.17.0.4:7051",
            "type": 1,
            "pkiID": "rUA+vX2jVCXev6JsXDNgNBMX03IV9mHRPWo6h6SI0KLMypBJLd+JoGGlqFgi+eq/"
        },
        {
            "ID": {
                "name": "vp3"
            },
            "address": "172.17.0.5:7051",
            "type": 1,
            "pkiID": "OBduaZJ72gmM+B9wp3aErQlofE0ulQfXfTHh377ruJjOpsUn0MyvsJELUTHpAbHI"
        },
        {
            "ID": {
                "name": "vp2"
            },
            "address": "172.17.0.6:7051",
            "type": 1,
            "pkiID": "GhtP0Y+o/XVmRNXGF6pcm9KLNTfCZp+XahTBqVRmaIumJZnBpom4ACayVbg4Q/Eb"
        }
    ]
}
</code></pre>
<h5>6.2.1.5 Registrar API (member services)</h5>
<ul>
<li><strong>POST /registrar</strong></li>
<li><strong>GET /registrar/{enrollmentID}</strong></li>
<li><strong>DELETE /registrar/{enrollmentID}</strong></li>
<li><strong>GET /registrar/{enrollmentID}/ecert</strong></li>
<li><strong>GET /registrar/{enrollmentID}/tcert</strong></li>
</ul>
<p>Use the Registrar APIs to manage end user registration with the certificate authority (CA). These API endpoints are used to register a user with the CA, determine whether a given user is registered, and to remove any login tokens for a target user from local storage, preventing them from executing any further transactions. The Registrar APIs are also used to retrieve user enrollment and transaction certificates from the system.</p>
<p>The <code>/registrar</code> endpoint is used to register a user with the CA. The required Secret payload is defined below. The response to the registration request is either a confirmation of successful registration or an error, containing a reason for the failure.</p>
<pre><code>message Secret {
    string enrollId = 1;
    string enrollSecret = 2;
}
</code></pre>
<ul>
<li><code>enrollId</code> - Enrollment ID with the certificate authority.</li>
<li><code>enrollSecret</code> - Enrollment password with the certificate authority.</li>
</ul>
<p>Enrollment Request:</p>
<pre><code>POST host:port/registrar

{
  "enrollId": "lukas",
  "enrollSecret": "NPKYL39uKbkj"
}
</code></pre>
<p>Enrollment Response:</p>
<pre><code>{
    "OK": "Login successful for user 'lukas'."
}
</code></pre>
<p>The <code>GET /registrar/{enrollmentID}</code> endpoint is used to confirm whether a given user is registered with the CA. If so, a confirmation will be returned. Otherwise, an authorization error will result.</p>
<p>Verify Enrollment Request:</p>
<pre><code>GET host:port/registrar/jim
</code></pre>
<p>Verify Enrollment Response:</p>
<pre><code>{
    "OK": "User jim is already logged in."
}
</code></pre>
<p>Verify Enrollment Request:</p>
<pre><code>GET host:port/registrar/alex
</code></pre>
<p>Verify Enrollment Response:</p>
<pre><code>{
    "Error": "User alex must log in."
}
</code></pre>
<p>The <code>DELETE /registrar/{enrollmentID}</code> endpoint is used to delete login tokens for a target user. If the login tokens are deleted successfully, a confirmation will be returned. Otherwise, an authorization error will result. No payload is required for this endpoint.</p>
<p>Remove Enrollment Request:</p>
<pre><code>DELETE host:port/registrar/lukas
</code></pre>
<p>Remove Enrollment Response:</p>
<pre><code>{
    "OK": "Deleted login token and directory for user lukas."
}
</code></pre>
<p>The <code>GET /registrar/{enrollmentID}/ecert</code> endpoint is used to retrieve the enrollment certificate of a given user from local storage. If the target user has already registered with the CA, the response will include a URL-encoded version of the enrollment certificate. If the target user has not yet registered, an error will be returned. If the client wishes to use the returned enrollment certificate after retrieval, keep in mind that it must be URL-decoded.</p>
<p>Enrollment Certificate Retrieval Request:</p>
<pre><code>GET host:port/registrar/jim/ecert
</code></pre>
<p>Enrollment Certificate Retrieval Response:</p>
<pre><code>{
    "OK": "-----BEGIN+CERTIFICATE-----%0AMIIBzTCCAVSgAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwNPQkMwHhcNMTYwMTIxMDYzNjEwWhcNMTYwNDIw%0AMDYzNjEwWjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNP%0AQkMwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAARSLgjGD0omuJKYrJF5ClyYb3sGEGTU%0AH1mombSAOJ6GAOKEULt4L919sbSSChs0AEvTX7UDf4KNaKTrKrqo4khCoboMg1VS%0AXVTTPrJ%2BOxSJTXFZCohVgbhWh6ZZX2tfb7%2BjUDBOMA4GA1UdDwEB%2FwQEAwIHgDAM%0ABgNVHRMBAf8EAjAAMA0GA1UdDgQGBAQBAgMEMA8GA1UdIwQIMAaABAECAwQwDgYG%0AUQMEBQYHAQH%2FBAE0MAoGCCqGSM49BAMDA2cAMGQCMGz2RR0NsJOhxbo0CeVts2C5%0A%2BsAkKQ7v1Llbg78A1pyC5uBmoBvSnv5Dd0w2yOmj7QIwY%2Bn5pkLiwisxWurkHfiD%0AxizmN6vWQ8uhTd3PTdJiEEckjHKiq9pwD%2FGMt%2BWjP7zF%0A-----END+CERTIFICATE-----%0A"
}
</code></pre>
<p>The <code>/registrar/{enrollmentID}/tcert</code> endpoint retrieves the transaction certificates for a given user that has registered with the certificate authority. If the user has registered, a confirmation message will be returned containing an array of URL-encoded transaction certificates. Otherwise, an error will result. The desired number of transaction certificates is specified with the optional 'count' query parameter. The default number of returned transaction certificates is 1; and 500 is the maximum number of certificates that can be retrieved with a single request. If the client wishes to use the returned transaction certificates after retrieval, keep in mind that they must be URL-decoded.</p>
<p>Transaction Certificate Retrieval Request:</p>
<pre><code>GET host:port/registrar/jim/tcert
</code></pre>
<p>Transaction Certificate Retrieval Response:</p>
<pre><code>{
    "OK": [
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQfwJORRED9RAsmSl%2FEowq1STBb%0A%2FoFteymZ96RUr%2BsKmF9PNrrUNvFZFhvukxZZjqhEcGiQqFyRf%2FBnVN%2BbtRzMo38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwSRWQFmErr0SmQO9AFP4GJYzQ%0APQMmcsCjKiJf%2Bw1df%2FLnXunCsCUlf%2FalIUaeSrT7MAoGCCqGSM49BAMDA0gAMEUC%0AIQC%2FnE71FBJd0hwNTLXWmlCJff4Yi0J%2BnDi%2BYnujp%2Fn9nQIgYWg0m0QFzddyJ0%2FF%0AKzIZEJlKgZTt8ZTlGg3BBrgl7qY%3D%0A-----END+CERTIFICATE-----%0A"
    ]
}
</code></pre>
<p>Transaction Certificate Retrieval Request:</p>
<pre><code>GET host:port/registrar/jim/tcert?count=5
</code></pre>
<p>Transaction Certificate Retrieval Response:</p>
<pre><code>{
    "OK": [
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARwJxVezgDcTAgj2LtTKVm65qft%0AhRTYnIOQhhOx%2B%2B2NRu5r3Kn%2FXTf1php3NXOFY8ZQbY%2FQbFAwn%2FB0O68wlHiro38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwRVPMSKVcHsk4aGHxBWc8PGKj%0AqtTVTtuXnN45BynIx6lP6urpqkSuILgB1YOdRNefMAoGCCqGSM49BAMDA0gAMEUC%0AIAIjESYDp%2FXePKANGpsY3Tu%2F4A2IfeczbC3uB%2BpziltWAiEA6Stp%2FX4DmbJGgZe8%0APMNBgRKeoU6UbgTmed0ZEALLZP8%3D%0A-----END+CERTIFICATE-----%0A",
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARwJxVezgDcTAgj2LtTKVm65qft%0AhRTYnIOQhhOx%2B%2B2NRu5r3Kn%2FXTf1php3NXOFY8ZQbY%2FQbFAwn%2FB0O68wlHiro38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwRVPMSKVcHsk4aGHxBWc8PGKj%0AqtTVTtuXnN45BynIx6lP6urpqkSuILgB1YOdRNefMAoGCCqGSM49BAMDA0gAMEUC%0AIAIjESYDp%2FXePKANGpsY3Tu%2F4A2IfeczbC3uB%2BpziltWAiEA6Stp%2FX4DmbJGgZe8%0APMNBgRKeoU6UbgTmed0ZEALLZP8%3D%0A-----END+CERTIFICATE-----%0A",
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARwJxVezgDcTAgj2LtTKVm65qft%0AhRTYnIOQhhOx%2B%2B2NRu5r3Kn%2FXTf1php3NXOFY8ZQbY%2FQbFAwn%2FB0O68wlHiro38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwRVPMSKVcHsk4aGHxBWc8PGKj%0AqtTVTtuXnN45BynIx6lP6urpqkSuILgB1YOdRNefMAoGCCqGSM49BAMDA0gAMEUC%0AIAIjESYDp%2FXePKANGpsY3Tu%2F4A2IfeczbC3uB%2BpziltWAiEA6Stp%2FX4DmbJGgZe8%0APMNBgRKeoU6UbgTmed0ZEALLZP8%3D%0A-----END+CERTIFICATE-----%0A",
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARwJxVezgDcTAgj2LtTKVm65qft%0AhRTYnIOQhhOx%2B%2B2NRu5r3Kn%2FXTf1php3NXOFY8ZQbY%2FQbFAwn%2FB0O68wlHiro38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwRVPMSKVcHsk4aGHxBWc8PGKj%0AqtTVTtuXnN45BynIx6lP6urpqkSuILgB1YOdRNefMAoGCCqGSM49BAMDA0gAMEUC%0AIAIjESYDp%2FXePKANGpsY3Tu%2F4A2IfeczbC3uB%2BpziltWAiEA6Stp%2FX4DmbJGgZe8%0APMNBgRKeoU6UbgTmed0ZEALLZP8%3D%0A-----END+CERTIFICATE-----%0A",
        "-----BEGIN+CERTIFICATE-----%0AMIIBwDCCAWagAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoG%0AA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMzExMjEwMTI2WhcNMTYwNjA5%0AMjEwMTI2WjApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwNq%0AaW0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARwJxVezgDcTAgj2LtTKVm65qft%0AhRTYnIOQhhOx%2B%2B2NRu5r3Kn%2FXTf1php3NXOFY8ZQbY%2FQbFAwn%2FB0O68wlHiro38w%0AfTAOBgNVHQ8BAf8EBAMCB4AwDAYDVR0TAQH%2FBAIwADANBgNVHQ4EBgQEAQIDBDAP%0ABgNVHSMECDAGgAQBAgMEMD0GBioDBAUGBwEB%2FwQwRVPMSKVcHsk4aGHxBWc8PGKj%0AqtTVTtuXnN45BynIx6lP6urpqkSuILgB1YOdRNefMAoGCCqGSM49BAMDA0gAMEUC%0AIAIjESYDp%2FXePKANGpsY3Tu%2F4A2IfeczbC3uB%2BpziltWAiEA6Stp%2FX4DmbJGgZe8%0APMNBgRKeoU6UbgTmed0ZEALLZP8%3D%0A-----END+CERTIFICATE-----%0A"
    ]
}
</code></pre>
<h5>6.2.1.6 Transactions API</h5>
<ul>
<li><strong>GET /transactions/{UUID}</strong></li>
</ul>
<p>Use the Transaction API to retrieve an individual transaction matching the UUID from the blockchain. The returned transaction message is defined in section <a href="#3121-transaction-data-structure">3.1.2.1</a>.</p>
<p>Transaction Retrieval Request:</p>
<pre><code>GET host:port/transactions/f5978e82-6d8c-47d1-adec-f18b794f570e
</code></pre>
<p>Transaction Retrieval Response:</p>
<pre><code>{
    "type": 3,
    "chaincodeID": "EgRteWNj",
    "payload": "Ch4IARIGEgRteWNjGhIKBmludm9rZRIBYRIBYhICMTA=",
    "uuid": "f5978e82-6d8c-47d1-adec-f18b794f570e",
    "timestamp": {
        "seconds": 1453758316,
        "nanos": 206716775
    },
    "cert": "MIIB/zCCAYWgAwIBAgIBATAKBggqhkjOPQQDAzApMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQwwCgYDVQQDEwN0Y2EwHhcNMTYwMTI1MjE0MTE3WhcNMTYwNDI0MjE0MTE3WjArMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMQ4wDAYDVQQDEwVsdWthczB2MBAGByqGSM49AgEGBSuBBAAiA2IABC/BBkt8izf6Ew8UDd62EdWFikJhyCPY5VO9Wxq9JVzt3D6nubx2jO5JdfWt49q8V1Aythia50MZEDpmKhtM6z7LHOU1RxuxdjcYDOvkNJo6pX144U4N1J8/D3A+97qZpKN/MH0wDgYDVR0PAQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwDQYDVR0OBAYEBAECAwQwDwYDVR0jBAgwBoAEAQIDBDA9BgYqAwQFBgcBAf8EMABNbPHZ0e/2EToi0H8mkouuUDwurgBYuUB+vZfeMewBre3wXG0irzMtfwHlfECRDDAKBggqhkjOPQQDAwNoADBlAjAoote5zYFv91lHzpbEwTfJL/+r+CG7oMVFUFuoSlvBSCObK2bDIbNkW4VQ+ZC9GTsCMQC5GCgy2oZdHw/x7XYzG2BiqmRkLRTiCS7vYCVJXLivU65P984HopxW0cEqeFM9co0=",
    "signature": "MGUCMCIJaCT3YRsjXt4TzwfmD9hg9pxYnV13kWgf7e1hAW5Nar//05kFtpVlq83X+YtcmAIxAK0IQlCgS6nqQzZEGCLd9r7cg1AkQOT/RgoWB8zcaVjh3bCmgYHsoPAPgMsi3TJktg=="
}
</code></pre>
<h3>6.3 CLI</h3>
<p>The CLI includes a subset of the available APIs to enable developers to quickly test and debug chaincodes or query for status of transactions. CLI is implemented in Golang and operable on multiple OS platforms. The currently available CLI commands are summarized in the following section.</p>
<h4>6.3.1 CLI Commands</h4>
<p>To see what CLI commands are currently available in the implementation, execute the following:</p>
<pre><code>$ peer
</code></pre>
<p>You will receive a response similar to below:</p>
<pre><code>    Usage:
      peer [command]

    Available Commands:
      node        node specific commands.
      network     network specific commands.
      chaincode   chaincode specific commands.
      help        Help about any command

    Flags:
      -h, --help[=false]: help for peer
          --logging-level="": Default logging level and overrides, see core.yaml for full syntax

    Use "peer [command] --help" for more information about a command.
</code></pre>
<p>Some of the available command line arguments for the <code>peer</code> command are listed below:</p>
<ul>
<li>
<p><code>-c</code> - constructor: function to trigger in order to initialize the chaincode state upon deployment.</p>
</li>
<li>
<p><code>-l</code> - language: specifies the implementation language of the chaincode. Currently, only Golang is supported.</p>
</li>
<li>
<p><code>-n</code> - name: chaincode identifier returned from the deployment transaction. Must be used in subsequent invoke and query transactions.</p>
</li>
<li>
<p><code>-p</code> - path: identifies chaincode location in the local file system. Must be used as a parameter in the deployment transaction.</p>
</li>
<li>
<p><code>-u</code> - username: enrollment ID of a logged in user invoking the transaction.</p>
</li>
</ul>
<p>Not all of the above commands are fully implemented in the current release. The fully supported commands that are helpful for chaincode development and debugging are described below.</p>
<p>Note, that any configuration settings for the peer node listed in the <code>core.yaml</code> configuration file, which is the  configuration file for the <code>peer</code> process, may be modified on the command line with an environment variable. For example, to set the <code>peer.id</code> or the <code>peer.addressAutoDetect</code> settings, one may pass the <code>CORE_PEER_ID=vp1</code> and <code>CORE_PEER_ADDRESSAUTODETECT=true</code> on the command line.</p>
<h5>6.3.1.1 node start</h5>
<p>The CLI <code>node start</code> command will execute the peer process in either the development or production mode. The development mode is meant for running a single peer node locally, together with a local chaincode deployment. This allows a chaincode developer to modify and debug their code without standing up a complete network. An example for starting the peer in development mode follows:</p>
<pre><code>peer node start --peer-chaincodedev
</code></pre>
<p>To start the peer process in production mode, modify the above command as follows:</p>
<pre><code>peer node start
</code></pre>
<h5>6.3.1.2 network login</h5>
<p>The CLI <code>network login</code> command will login a user, that is already registered with the CA, through the CLI. To login through the CLI, issue the following command, where <code>username</code> is the enrollment ID of a registered user.</p>
<pre><code>peer network login &lt;username&gt;
</code></pre>
<p>The example below demonstrates the login process for user <code>jim</code>.</p>
<pre><code>peer network login jim
</code></pre>
<p>The command will prompt for a password, which must match the enrollment password for this user registered with the certificate authority. If the password entered does not match the registered password, an error will result.</p>
<pre><code>22:21:31.246 [main] login -&gt; INFO 001 CLI client login...
22:21:31.247 [main] login -&gt; INFO 002 Local data store for client loginToken: /var/hyperledger/production/client/
Enter password for user 'jim': ************
22:21:40.183 [main] login -&gt; INFO 003 Logging in user 'jim' on CLI interface...
22:21:40.623 [main] login -&gt; INFO 004 Storing login token for user 'jim'.
22:21:40.624 [main] login -&gt; INFO 005 Login successful for user 'jim'.
</code></pre>
<p>You can also pass a password for the user with <code>-p</code> parameter. An example is below.</p>
<pre><code>peer network login jim -p 123456
</code></pre>
<h5>6.3.1.3 chaincode deploy</h5>
<p>The CLI <code>deploy</code> command creates the docker image for the chaincode and subsequently deploys the package to the validating peer. An example is below.</p>
<pre><code>peer chaincode deploy -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -c '{"Function":"init", "Args": ["a","100", "b", "200"]}'
</code></pre>
<p>With security enabled, the command must be modified to pass an enrollment id of a logged in user with the <code>-u</code> parameter. An example is below.</p>
<pre><code>peer chaincode deploy -u jim -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -c '{"Function":"init", "Args": ["a","100", "b", "200"]}'
</code></pre>
<p><strong>Note:</strong> If your GOPATH environment variable contains more than one element, the chaincode must be found in the first one or deployment will fail.</p>
<h5>6.3.1.4 chaincode invoke</h5>
<p>The CLI <code>invoke</code> command executes a specified function within the target chaincode. An example is below.</p>
<pre><code>peer chaincode invoke -n &lt;name_value_returned_from_deploy_command&gt; -c '{"Function": "invoke", "Args": ["a", "b", "10"]}'
</code></pre>
<p>With security enabled, the command must be modified to pass an enrollment id of a logged in user with the <code>-u</code> parameter. An example is below.</p>
<pre><code>peer chaincode invoke -u jim -n &lt;name_value_returned_from_deploy_command&gt; -c '{"Function": "invoke", "Args": ["a", "b", "10"]}'
</code></pre>
<h5>6.3.1.5 chaincode query</h5>
<p>The CLI <code>query</code> command triggers a specified query method within the target chaincode. The response that is returned depends on the chaincode implementation. An example is below.</p>
<pre><code>peer chaincode query -l golang -n &lt;name_value_returned_from_deploy_command&gt; -c '{"Function": "query", "Args": ["a"]}'
</code></pre>
<p>With security enabled, the command must be modified to pass an enrollment id of a logged in user with the <code>-u</code> parameter. An example is below.</p>
<pre><code>peer chaincode query -u jim -l golang -n &lt;name_value_returned_from_deploy_command&gt; -c '{"Function": "query", "Args": ["a"]}'
</code></pre>
<h2>7. Application Model</h2>
<h3>7.1 Composition of an Application</h3>
<table>


<tbody><tr>
<td width="50%"><a href="images/refarch-app.png" target="_blank"><img src="images/refarch-app.png" style="max-width:100%;"></a></td>
<td valign="top">
An application follows a MVC-B architecture – Model, View, Control, BlockChain.
<p></p><p>
</p><ul>
  <li>VIEW LOGIC – Mobile or Web UI interacting with control logic.</li>
  <li>CONTROL LOGIC – Coordinates between UI, Data Model and APIs to drive transitions and chain-code.</li>
  <li>DATA MODEL – Application Data Model – manages off-chain data, including Documents and large files.</li>
  <li>BLOCKCHAIN  LOGIC – Blockchain logic are extensions of the Controller Logic and Data Model, into the Blockchain realm. Controller logic is enhanced by chaincode, and the data model is enhanced with transactions on the blockchain.</li>
</ul>
<p>
For example, a Bluemix PaaS application using Node.js might have a Web front-end user interface or a native mobile app with backend model on Cloudant data service. The control logic may interact with 1 or more chaincodes to process transactions on the blockchain.
</p></td>
</tr>
</tbody></table>
<h3>7.2 Sample Application</h3>
<h2>8. Future Directions</h2>
<h3>8.1 Enterprise Integration</h3>
<h3>8.2 Performance and Scalability</h3>
<h3>8.3 Additional Consensus Plugins</h3>
<h3>8.4 Additional Languages</h3>
<h3>9.1 Authors</h3>
<p>The following authors have written sections of this document:  Binh Q Nguyen, Elli Androulaki, Angelo De Caro, Sheehan Anderson, Manish Sethi, Thorsten Kramp, Alessandro Sorniotti, Marko Vukolic, Florian Simon Schubert, Jason K Yellick, Konstantinos Christidis, Srinivasan Muralidharan, Anna D Derbakova, Dulce Ponceleon, David Kravitz, Diego Masini.</p>
<h3>9.2 Reviewers</h3>
<p>The following reviewers have contributed to this document:  Frank Lu, John Wolpert, Bishop Brock, Nitin Gaur, Sharon Weed, Konrad Pabjan.</p>
<h3>9.3 Acknowledgements</h3>
<p>The following contributors have provided invaluable technical input to this specification:<br>
Gennaro Cuomo, Joseph A Latone, Christian Cachin</p>
<h2>10. References</h2>
<ul>
<li>
<p>[1] Miguel Castro, Barbara Liskov: Practical Byzantine fault tolerance and proactive recovery. ACM Trans. Comput. Syst. 20(4): 398-461 (2002)</p>
</li>
<li>
<p>[2] Christian Cachin, Rachid Guerraoui, Luís E. T. Rodrigues: Introduction to Reliable and Secure Distributed Programming (2. ed.). Springer 2011, ISBN 978-3-642-15259-7, pp. I-XIX, 1-367</p>
</li>
<li>
<p>[3] Tushar Deepak Chandra, Vassos Hadzilacos, Sam Toueg: The Weakest Failure Detector for Solving Consensus. J. ACM 43(4): 685-722 (1996)</p>
</li>
<li>
<p>[4] Cynthia Dwork, Nancy A. Lynch, Larry J. Stockmeyer: Consensus in the presence of partial synchrony. J. ACM 35(2): 288-323 (1988)</p>
</li>
<li>
<p>[5] Manos Kapritsos, Yang Wang, Vivien Quéma, Allen Clement, Lorenzo Alvisi, Mike Dahlin: All about Eve: Execute-Verify Replication for Multi-Core Servers. OSDI 2012: 237-250</p>
</li>
<li>
<p>[6] Pierre-Louis Aublin, Rachid Guerraoui, Nikola Knezevic, Vivien Quéma, Marko Vukolic: The Next 700 BFT Protocols. ACM Trans. Comput. Syst. 32(4): 12:1-12:45 (2015)</p>
</li>
<li>
<p>[7] Christian Cachin, Simon Schubert, Marko Vukolić: <a href="http://arxiv.org/abs/1603.07351">Non-determinism in Byzantine Fault-Tolerant Replication</a></p>
</li>
</ul>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
