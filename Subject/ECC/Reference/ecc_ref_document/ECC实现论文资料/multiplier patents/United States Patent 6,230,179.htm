<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0157)http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=/netahtml/srchnum.htm&r=1&f=G&l=50&s1=6230179.WKU.&OS=PN/6230179&RS=PN/6230179 -->
<HTML><HEAD><TITLE>United States Patent: 6,230,179</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content="MSHTML 6.00.2800.1505" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff><A name=top></A>
<CENTER><IMG 
alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" 
src="United States Patent 6,230,179.files/patfthdr.gif"> <BR><!-- <IMG border=0 src=/netaicon/PTO/titlebar.gif><br> -->
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A href="http://www.uspto.gov/patft/index.html"><IMG 
      alt=[Home] src="United States Patent 6,230,179.files/home.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
      alt="[Boolean Search]" 
      src="United States Patent 6,230,179.files/boolean.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG 
      alt="[Manual Search]" 
      src="United States Patent 6,230,179.files/manual.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG 
      alt="[Number Search]" 
      src="United States Patent 6,230,179.files/number.gif" border=0 
      valign="middle"></A> <A 
      href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
      src="United States Patent 6,230,179.files/help.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=6230179.WKU.&amp;OS=PN/6230179&amp;RS=PN/6230179#bottom"><IMG 
      alt=[Bottom] src="United States Patent 6,230,179.files/bottom.gif" 
      border=0 valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6230179.WKU.%26OS%3DPN%2F6230179&amp;backLabel1=Back%20to%20Document%3A%206,230,179"><IMG 
      alt="[View Shopping Cart]" 
      src="United States Patent 6,230,179.files/cart.gif" border=0 
      valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,230,179&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6230179.WKU.%26OS%3DPN%2F6230179&amp;backLabel1=Back%20to%20Document%3A%206,230,179"><IMG 
      alt="[Add to Shopping Cart]" 
      src="United States Patent 6,230,179.files/order.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patimg2.uspto.gov/.piw?Docid=06230179&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO1%2526Sect2%3DHITOFF%2526d%3DPALL%2526p%3D1%2526u%3D%2Fnetahtml%2Fsrchnum.htm%2526r%3D1%2526f%3DG%2526l%3D50%2526s1%3D6230179.WKU.%2526OS%3DPN%2F6230179%2526RS%3DPN%2F6230179&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=2525F81E1B7C"><IMG 
      alt=[Image] src="United States Patent 6,230,179.files/image.gif" border=0 
      valign="middle"></A> <!-- <A HREF=""><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A>
<BR><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ULL </FONT><FONT SIZE=4 COLOR="#CC3300">T</FONT><FONT SIZE=2 COLOR="#CC3300">EXT </FONT><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ORMAT</FONT></STRONG> --></TD></TR></TBODY></TABLE></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%">&nbsp;</TD>
    <TD vAlign=bottom align=right width="50%"><FONT size=-1>( 
      <STRONG>1</STRONG></FONT> <FONT size=-2>of</FONT> <STRONG><FONT 
      size=-1>1</STRONG> )</FONT></TD></TR></TBODY></TABLE>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%"><B>United States Patent </B></TD>
    <TD align=right width="50%"><B><B><I>6,230,179</I></B> </B></TD></TR>
  <TR>
    <TD align=left width="50%"><B>Dworkin , &nbsp; et al.</B> <!-- 2: Dworkin; James Douglas
,Torla; Michael John
,Glaser; P. Michael
,Vadekar; Ashok
<br>Dworkin, ;, , ,  --></TD>
    <TD align=right width="50%"><B>May 8, 2001 </B></TD></TR></TBODY></TABLE>
<HR>
<FONT size=+1>Finite field multiplier with intrinsic modular reduction 
</FONT><BR><BR>
<CENTER><B>Abstract</B></CENTER>
<P>A finite field multiplier with intrinsic modular reduction includes an 
interface unit (1208) that translates an n bit wide data path to a m bit wide 
data path where n is less than m. Also included is a finite field data unit 
(1204) with m bit wide registers that is coupled to a finte field control unit 
(1202). The finite field control unit (1202) includes a microsequencer (1402) 
and a finite state machine multiplier (1404). The microsequencer (1402) controls 
the finite state machine multiplier (1404) which performs a finite field 
multiply operation with intrinsic modular reduction and presents a finite field 
multiplication product to the finite field data unit (1204). </P>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="10%">Inventors: </TD>
    <TD align=left width="90%"><B>Dworkin; James Douglas</B> (Chandler, AZ); 
      <B>Torla; Michael John</B> (Chandler, AZ); <B>Glaser; P. Michael</B> 
      (Tempe, AZ); <B>Vadekar; Ashok</B> (Mississauga, CA); <B>Lambert; Robert 
      John</B> (Hespeler, CA); <B>Vanstone; Scott Alexander</B> (Waterloo, CA) 
    </TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Assignee: </TD>
    <TD align=left width="90%"><B>Motorola, Inc.</B> (Schaumburg, IL); 
      <B>Certicom Corp.</B> (Ontario, CA) </TD></TR>
  <TR>
    <TD vAlign=top noWrap align=left width="10%">Appl. No.: </TD>
    <TD align=left width="90%"><B>997960</B></TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Filed: </TD>
    <TD align=left width="90%"><B>December 24, 1997</B></TD></TR></TBODY></TABLE>
<CENTER><B>Foreign Application Priority Data</B></CENTER>
<HR align=center width="30%">

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%"></TD>
    <TD>Apr 18, 1997[GB]</TD>
    <TD>9707861</TD></TR></TBODY></TABLE>
<P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Current U.S. Class:</B></TD>
    <TD vAlign=top align=right width="60%"><B>708/492</B> </TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Intern'l Class: </B></TD>
    <TD vAlign=top align=right width="60%">G06F 007/00</TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Field of Search: </B></TD>
    <TD vAlign=top align=right width="60%">708/491-492,625 
</TD></TR></TBODY></TABLE>
<HR>

<CENTER><B>References Cited <A 
href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=CR01&amp;Query=ref/6,230,179">[Referenced 
By]</A></B></CENTER>
<HR>

<CENTER><B>U.S. Patent Documents</B></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4216531">4216531</A></TD>
    <TD width="25%">Aug., 1980</TD>
    <TD align=left width="25%">Chiu</TD>
    <TD align=right width="25%">708/625. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5467297">5467297</A></TD>
    <TD width="25%">Nov., 1995</TD>
    <TD align=left width="25%">Zook</TD>
    <TD align=right width="25%">708/492. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5612910">5612910</A></TD>
    <TD width="25%">Mar., 1997</TD>
    <TD align=left width="25%">Meyer</TD>
    <TD align=right width="25%">708/492. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5854759">5854759</A></TD>
    <TD width="25%">Dec., 1998</TD>
    <TD align=left width="25%">Kaliski, Jr. et al.</TD>
    <TD align=right width="25%">708/492. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5999959">5999959</A></TD>
    <TD width="25%">Dec., 1999</TD>
    <TD align=left width="25%">Weng et al.</TD>
    <TD align=right width="25%">708/492. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6049815">6049815</A></TD>
    <TD width="25%">Apr., 2000</TD>
    <TD align=left width="25%">Lambert et al.</TD>
    <TD align=right width="25%">708/492. </TD></TR></TBODY></TABLE><BR><I>Primary 
Examiner:</I> Mai; Tan V. <BR><I>Attorney, Agent or Firm:</I> Macnak; Philip P. 
<BR>
<HR>

<CENTER><B><I>Claims</B></I></CENTER>
<HR>
<BR><BR>We claim: <BR><BR>1. A finite field multiplier with intrinsic modular 
reduction, comprising: <BR><BR>an interface unit that translates an n bit wide 
data path to a m bit wide data path where n is less than m; <BR><BR>a finite 
field data unit coupled to the interface unit, the finite field data unit 
comprising m bit wide registers coupled to an arithmetic logic unit; and 
<BR><BR>a finite field control unit coupled to the finite field data unit, the 
finite field control unit comprising <BR><BR>a microsequencer, and <BR><BR>a 
finite state machine for controlling the finite field multipliers <BR><BR>the 
microsequencer having a control port that accepts a signal requesting a finite 
field multiplication, and upon receiving the signal requesting a finite field 
multiplication, the microsequencer sends a start signal to the finite state 
machine which performs a finite field multiply operation and upon completion of 
the finite field multiply operation, the finite state machine sends a done 
signal to the microsequencer indicating completion of the finite field multiply 
operation, the finite state machine further coupling a finite field 
multiplication product to the finite field data unit. <BR><BR>2. The finite 
field multiplier according to claim 1 wherein m is 256 and n is 32. <BR><BR>3. 
The finite field multiplier according to claim 1 wherein the finite field data 
unit comprises four m bit wide registers coupled to the interface unit and to 
the finite field control unit. <BR><BR>4. The finite field multiplier according 
to claim 3 wherein the four m bit wide registers are shift registers designated 
as B, A, M, and C, where B is a multiplier register, A is a multiplicand 
register, M is a modulo factor register, and C is a product register, which are 
used to provide a finite field multiplication when coupled to the arithmetic 
logic unit (ALU for performing multiplying. adding. and subtracting. with the 
finite state machine operating to multiply B by A by repeating the following 
procedure m times: <BR><BR>a current finite field partial product is formed by 
multiplying each bit of B, one at a time, by all bits of A; <BR><BR>the current 
finite field partial product is added to a 1-bit shifted version of a previous 
finite field partial product, if any, to form an accumulated finite field 
partial product which is stored in C; and <BR><BR>when a most significant bit of 
the accumulated finite field partial product is 1, a modulo factor in M is 
subtracted from the accumulated finite field partial product stored in C to 
insure that the finite field multiplication product remains less than an 
irreducible value. <BR><BR>5. The finite field multiplier according to claim 4 
wherein the 1-bit shifted version of a previous finite field partial product is 
formed by left shifting the previous finite field partial product 1-bit. 
<BR><BR>6. In a finite field multiplier having four m bit wide shift registers 
designated as B, A, M, and C, where B is a multiplier register, A is a 
multiplicand register, M is a modulo factor register, and C is a product 
register, which are used to provide a finite field multiplication when coupled 
to an arithmetic logic unit (ALU) for performing multiplying, adding, and 
subtracting, a method for computing a finite field product with intrinsic 
modular reduction comprising the steps of: <BR><BR>forming a current finite 
field partial product by multiplying each bit of B, one at a time, by all bits 
of A; <BR><BR>adding the current finite field partial product to a 1-bit shifted 
version of a previous finite field partial product, if any, to form an 
accumulated finite field partial product which is stored in C; <BR><BR>when a 
most significant bit of the accumulated finite field partial product stored in C 
is 1, subtracting a modulo factor in M from the accumulated finite field partial 
product to insure that the finite field multiplication product remains less than 
an irreducible value; and repeating the forming and adding steps, and if 
necessary, the subtracting step, m times to complete the finite field 
multiplication. 
<HR>

<CENTER><B><I>Description</B></I></CENTER>
<HR>
<BR><BR>FIELD OF THE INVENTION <BR><BR>The present invention relates to a method 
and apparatus for performing finite field and integer arithmetic. 
<BR><BR>BACKGROUND OF THE INVENTION <BR><BR>Elliptic Curve(EC) cryptography over 
a finite field require arithmetic operations of addition, multiplication, 
squaring and inversion. Additionally, subtraction operations are also required 
if the field is not of characteristic two. Modular arithmetic operations are 
also required, for example in computing signatures, however these operations are 
required less frequently than the finite field operations. EC cryptography as an 
example, requires the full complement of modular operations, addition, 
subtraction, multiplication and inversion. <BR><BR>Field sizes for cryptography 
tend to be relatively large, requiring fast, dedicated processors to perform the 
arithmetic operations in an acceptable time. Thus there have been numerous 
implementations of either fast modular arithmetic processor or dedicated 
processors for performing arithmetic operations in F.sub.2.sup.m. 
<BR><BR>Traditionally RSA was the encryption system of choice, however with the 
advent of superior and more secure EC cryptography the need for processors that 
perform modular exponentiation exclusively is becoming less imperative. Thus 
while users are in transition from RSA cryptography to EC cryptography there is 
a need for an arithmetic processor that supports both these operations, with 
little or no penalty in performance. <BR><BR>SUMMARY OF THE INVENTION <BR><BR>It 
is an object of the invention to provide a processor that combines finite field 
arithmetic and integer arithmetic and for providing operations required for EC 
cryptography. <BR><BR>It is a further object of the invention to provide an 
arithmetic processor design that may be scaled to different field or register 
sizes. <BR><BR>A still further object of the invention to provide an arithmetic 
processor that may be used with different field sizes. <BR><BR>A still further 
object of the invention is to provide an arithmetic processor that is capable of 
being scaled to provide an increase in speed when performing multi-sequence 
operations by simultaneously executing multiple steps in the sequence. 
<BR><BR>In accordance with an embodiment of the invention there is provided an 
arithmetic processor that performs both finite field arithmetic and integer 
arithmetic and in which both special purpose registers and general purpose 
registers, and arithmetic circuits, are shared. For this purpose, a polynomial 
basis for the finite field hardware will be assumed, since this basis is similar 
to the standard radix-power basis of the integers. <BR><BR>In accordance with a 
further embodiment of the invention, there is provided a processor that includes 
finite field circuitry and integer arithmetic circuitry and which includes 
general-purpose registers, and special-purpose registers, wherein the 
special-purpose registers are not shared by the arithmetic circuitry. <BR><BR>In 
accordance with this invention there is provide an arithmetic processor 
comprising: finite field arithmetic circuitry; integer arithmetic circuitry; and 
mode control means for selectively enabling either the finite field circuitry or 
integer arithmetic circuitry. <BR><BR>BRIEF DESCRIPTION OF THE DRAWINGS 
<BR><BR>Embodiments of the invention will now be described by way of example 
only with reference to the accompanying drawings in which: <BR><BR>FIG 1 is a 
block diagram of an arithmetic processor architecture for performing finite 
field arithmetic and integer arithmetic; <BR><BR>FIG. 2 is a block schematic 
diagram of the ALU shown in FIG. 1; <BR><BR>FIG. 3 is a block diagrams of an 
alternative embodiment of an arithmetic processor architecture for performing 
finite field arithmetic and integer arithmetic; <BR><BR>FIG. 4 is a block 
schematic diagram of the ALU shown in FIG. 3; <BR><BR>FIG. 5 is a block diagram 
of an embodiment of a bit-slice of the ALU shown in FIG. 2; <BR><BR>FIG. 6 is a 
circuit diagram of a finite-field multiplier of the bit-slice shown in FIG. 5; 
<BR><BR>FIG. 7 is a block diagram of an arithmetic inverter; <BR><BR>FIG. 8 is a 
circuit diagram of a combined finite-field/integer multiplier; <BR><BR>FIG. 9 is 
a block schematic diagram showing an embodiment of a multi-bit ALU of FIG. 1; 
<BR><BR>FIG. 10 is a circuit diagram of the multi-bit finite-field multiplier of 
FIG. 9; <BR><BR>FIG. 11 is a structure of a circuit that performs finite field 
multiplication; <BR><BR>FIG. 12 is a block diagram of a finite field data unit, 
a finite field control unit, and an interface unit; <BR><BR>FIG. 13 is a 
structure of the finite field data unit; and <BR><BR>FIG. 14 is a block diagram 
of the finite field control unit. <BR><BR>DESCRIPTION OF A PREFERRED EMBODIMENT 
<BR><BR>Referring to FIG. 1, an embodiment of an arithmetic processor is shown 
generally by numeral 1. The arithmetic processor includes a group of general 
purpose registers 2, termed a register file (which may be used as intermediate 
storage for EC point additions, point doublings, etc.), which communicate with 
an arithmetic-logic unit (ALU) 4, via data input buses 6. The ALU 4 includes 
shared finite field and integer arithmetic circuitry. A data output bus 14 is 
provided from the ALU 4 to the register file 2 for writing results of 
computations performed in the ALU 4 to the register file 2. Computational 
operations of the ALU 4 are controlled via micro-programmed instructions 
residing in a controller 8 section of the arithmetic processor 1. A mode 
selection control 10 is provided to select between either finite field 
computations or modular integer computations. A field size control 12 is also 
provided for initializing the ALU 4 to accommodate different operand vector 
sizes. Thus the controller 8 performs the following tasks amongst others: 
provides the appropriate arithmetic mode and operation to the ALU 4; coordinates 
data access between the register file 2 and the ALU 4; and provides to the ALU 4 
the appropriate field size to be used. The general-purpose registers are chosen 
to have a width large enough to handle at least the largest foreseeable 
F.sub.2.sup.m EC cryptosystem. The registers may be combined to support larger 
lengths required for integer modular arithmetic. For example if a single 
register in the register file 2 is 512 bits wide, then four registers may be 
used to provide storage for a single 2048-bit RSA quantity. <BR><BR>Turning now 
to FIG. 2, the ALU 4 includes several special purpose registers 16, 
combinatorial logic and arithmetic circuitry contained in a plurality of 
sub-ALU's 18, input data buses 28 to each of the sub ALU's from the special 
purpose registers; output data buses 30 to the special purpose registers 16 from 
the sub ALU's 18 and its own controller 20. The controller 20 performs the 
following tasks amongst others: sequences the ALU 4 through steps in a 
computational operation; monitors control bits from the special purpose 
registers 16; and implements a counter in its own control registers 22 for 
determining the size of a field being used, a feature which allows the processor 
1 to be used for different field sizes without having to redesign the processor 
hardware. In order to provide these functions, the control bits 26 of the 
special purpose registers 16 are provided as control bit inputs 24 to the 
controller 20. The special purpose registers 16 are all individually 
addressable. The controller 20 also controls data input via the input buses 6 
from and to the register file to the sub ALU's 16 or the special purpose 
registers 16. Each of these components will be described in more detail below. 
<BR><BR>Referring to FIG. 3, an alternative embodiment of an arithmetic 
processor is shown generally by numeral 1'. In this embodiment a separate finite 
field unit 34 and integer modular arithmetic unit 36 is provided. This processor 
also includes a register file 2', data input buses 6', data output buses 14', 
and a controller 8' however separate controls 13a and 13b are provided from the 
controller 8' to respective ALU's 34 and 36 respectively. <BR><BR>Referring to 
FIG. 4, the ALU's 34 and 36 of FIG. 3 are shown in greater detail. Each of the 
ALU's 34 and 36 include their own respective special-purpose registers 16'a and 
16'b and controller 20'a and 20'b. Each of the ALU's 34 and 36 contain their own 
sub ALU's 18'a and 18'b respectively. Thus it may be seen that in this 
embodiment special purpose registers 16'a and 16'b and arithmetic and control 
circuitry is not shared. One or more of the sub ALU's 18'a perform the functions 
of Shift left/right, XOR-shift and one or more of the sub ALU's 18'b perform the 
function of integer add and integer subtract. <BR><BR>Referring back to FIG. 2, 
the sub ALU's 18 perform the following logical functions on operands provided 
from the special purpose registers 16: XOR; Shift left/right, XOR-shift, integer 
add and integer subtract. These functions may be contained in one sub ALU 18 or 
across multiple sub ALUS. By providing multiple sub ALU's 18 the processor is 
capable of performing multiple operations, (e.g. for finite field inversion), 
simultaneously. <BR><BR>Turning now to FIG. 5, a bit-slice 41 of the ALU 4 shown 
in FIG. 2 is shown in greater detail. In the following discussion, we shall 
refer to the interconnection of cells of respective special-purpose registers in 
conjunction with its associated logic circuitry as a bit-slice 41. The logic 
circuitry contained in a bit slice is generally represented schematically by one 
of the sub ALU's 18. It is then intended that the configuration of a bit slice 
may be repeated M times for an M-bit register. Furthermore, for clarity, we 
define M to be the number of cells in a register, and we refer to individual 
cells in a register as, for example, A.sub.i where 1.ltoreq.i.ltoreq.M and 
wherein A.sub.M is the right most cell of the special-purpose register. The 
contents of a register will be referred to by lower case letters, for example, a 
bit vector of length m will have bits numbered from a.sub.0 . . . a.sub.m-1 with 
a.sub.0 being the LSB. It may also be noted that although the special-purpose 
registers have been given specific names, these registers may take on different 
functions depending on the arithmetic operation being performed as will be 
described below. <BR><BR>In FIG. 5, the special-purpose registers 16 include: a 
pair of operand registers A 42 and B 44, to hold for example the multiplicand 
and multiplier, respectively, in a multiplication operation; an accumulator 
register C 46; a modulus register M 48; and a carry extension register C.sup.ext 
50. The registers each have M cells for holding the respective binary digits of 
bit vectors loaded therein. It is preferable that these registers are shift 
registers. A sub ALU 18 shown in FIG. 2 may be implemented by the circuitry of 
block 52 in FIG. 5, and in a manner to be described below. <BR><BR>Operation of 
the ALU 4 may be best understood by reference to a specific arithmetic operation 
such as finite field multiplication. Consider the product C of two elements a 
and b, where a and b are bit vectors and wherein b will be of the form 
b=(b.sub.0, . . . b.sub.n-1) in polynomial basis representation and a will be of 
the form a=(a.sub.0, . . . a.sub.n-1) in polynomial basis representation. A 
modulus bit vector m has the form m=(m.sub.0, . . . m.sub.n). In F.sub.2.sup.m, 
the multiplication may be implemented as a series of steps, which is more 
clearly set out by the following pseudo-code: <BR><BR>C=0 <BR><BR>For i from n-1 
to 0do <BR><BR>For j from n-1 to 0 do { <BR><BR>c.sub.j =c.sub.j-1 +b.sub.i 
(a.sub.i)+c.sub.n-1 (m.sub.j) <BR><BR>} <BR><BR>In performing the 
multiplication, partial products of the multiplicand and each of the bits of bi 
of the multiplier, proceeding from the most significant bit (MSB) to the least 
significant bit (LSB), are formed. The partial products are reduced by the 
modulus if the MSB of the previous partial product is set. 
<BR><BR>Multiplication may be implemented by sequentially using a 1.times.M 
multiplier. The modulus register M is loaded with the modulus bit vector M 
stripped of its most significant bit mn such that each cell contains a 
respective one of the binary digits mi. In the implementation shown, the bits 
m.sub.i is arranged from left to right with the MSB of the vector being the 
leftmost bit, i.e. cell M.sub.M contains bit M.sub.n-1. The shift registers A 
and B are loaded with the finite field elements bit vectors a and b respectively 
so that each cell contains one of the binary digits a.sub.i or b.sub.i. The 
finite field elements a and b are also stored left justified, and in reverse 
order, in their respective registers so that the topmost bit of the multiplier 
register b is always available at the left boundary cell bit, i.e. (a.sub.n-1, 
a.sub.n-2, . . . a.sub.0) and (b.sub.n-1, b.sub.n-2, . . . b.sub.0). If the 
length of the vectors a and b are less than the length of the registers; the 
remaining cells are padded with zeros. The above is generally performed by the 
controller 20 shown in FIG. 2. Other arrangements of sequential multiplication 
are possible (such as sequentially reducing the multiplicand), but such 
arrangements do not allow flexible field sizes along with fixed control bit 
locations. Bit ordering from LSB to MSB is also possible with corresponding 
changes in the multiplication algorithm. <BR><BR>A bit-slice 41 of the ALU 4 for 
implementing multiplication in a finite field is now described. The bit-slice 41 
includes first and second controllable adders 54 and 56, respectively, each 
having an XOR function. The topmost cell B.sub.M of the register B provides an 
add control signal b.sub.m 57 to the first adder 54. Inputs 58 and 60 to the 
first adder 54 are derived from a register cell A.sub.i and accumulator cell 
C.sub.i. An output 62 from the first adder 54 is connected to an input of the 
second adder 56 along with an input 64 from the modulus register cell M.sub.i. 
<BR><BR>The output from the second adder 56 is then connected the accumulator 
cell C.sub.i. A second add control signal 66 is derived from the topmost cell 
C.sub.M of the accumulator C 46. It may be seen that this signal implements the 
modular reduction of the partial product in the accumulator C by the modulus 
vector m, when the topmost bit C.sub.M of C is set. The B register is a clocked 
shift register. A clock signal CLK168, which may be provided by the controller 
20 causes the contents of this register to be shifted left for each partial 
product, calculated. <BR><BR>Referring to FIG. 6, a detailed circuit 
implementation of the bit-slice 41 of FIG. 5 for finite field multiplication is 
indicated by numeral 70. Referring to bit-slice i, 70 of FIG. 6, (only three 
bit-slices are shown for the purpose of illustration in FIG. 6), the cell 
a.sub.i is ANDed with the add control signal b.sub.m by an AND gate 72. The 
output 74 of the AND gate 72 is connected to an input of an XOR gate 76 along 
with an input 78 from adjacent cell C.sub.i-1 of the accumulator C. Thus 
implementing the calculation of the term "c.sub.j-1 +b.sub.i (a.sub.i)." The 
term "c.sub.n-1 (m.sub.j)" is implemented by ANDing the signal c.sub.n 80 with 
m.sub.i 82 utilizing an AND gate 84. The output 86 of the AND gate 84 is 
connected to the input of an XOR gate 84, along with the output 88 of XOR gate 
76. The output 90 of XOR gate 84 is connected to cell C.sub.i 92. Thus 
implementing the expression "c.sub.j =c.sub.j-1 +b.sub.i (a.sub.j)+c.sub.n-1 
(m.sub.j)." With this general sequential multiplier, the product of two n-bit 
finite field elements will be produced in n clock cycles. It is preferable that 
a synchronous counter, that may be contained in the controller 20, provides 
control of the number of iterations. <BR><BR>Addition <BR><BR>Although the 
circuitry has been described with reference to multiplication in a finite field 
F.sub.2.sup.m, other computational operations may also be performed with ease. 
Finite field addition has an advantage over integer arithmetic in that no 
carries are produced. The computation of a finite field sum requires only that 
an XOR gate be introduced at each cell of the registers in question since 
addition of two elements a and b in a finite field is simply a EXOR b. Thus, 
referring back to FIG. 5, an input 100 is provided to the first adder 54 from 
cell B.sub.i, and the second adder 56 may be bypassed. The output from adder 54 
is then written directly into cell C.sub.i. After the operands have been moved 
into registers a and b, the addition can be performed in a single clock cycle. 
It is also possible for the operation to be performed in the ALU and the result 
written back into a general register in the register file. <BR><BR>Squaring 
<BR><BR>Squaring a number can be performed in the same time as multiplication of 
two different numbers. Squaring in a polynomial basis can be performed in a 
single clock cycle, if the specific irreducible along with the squaring 
expansion is explicitly hardwired <BR><BR>Inversion <BR><BR>Inversion of finite 
field elements in F.sub.2.sup.m may be performed using the extended Euclidean 
algorithm and utilizing four of the special purpose registers with additional 
control logic. This will be completed in 2n cycles if the shifting is made 
concurrently to the adds (which is easily implemented by hard wiring the outputs 
of the add to the next register cell). <BR><BR>The registers used in the 
inversion are A, B, M and C. For convenience these registers are schematically 
shown in FIG. 7 wherein they are assigned the following labels: A:UL; B:LL; 
M:UR; and C:LR. Once again the operation may be described with reference to a 
bit-slice 110. <BR><BR>The operands in an inversion are generally: an element to 
invert g; an irreducible polynomial for modulus m; a bit vector "0" and a bit 
vector "1." The UL register 116 is loaded with f or m. The LL register 118 is 
loaded with g, the UR register 112 is loaded with "0" and the LR register 114 is 
loaded with "1." For the UR and LR registers 112 and 114, respectively, cells 
UR.sub.i and LR.sub.i are XORed together by XOR gate 120 to produce an output 
122. A control signal 124 determines whether one of three possible inputs is 
written in cell UR.sub.i and UL.sub.i. The inputs are either a left or right 
shift from adjacent cells or the output 122. The control signal B determined by 
the state table to be described below. For the UL or LL registers 116 and 118, 
respectively, cells UL.sub.I and LL.sub.I are XORed together by XOR gate 126 to 
produce an output 128. A control signal 130 determines whether one of two 
possible inputs is written into cell UL.sub.i and LL.sub.i. The inputs are 
either a left shift from the adjacent cell (i-1) or the output 128. Once again 
the control signal 130 is determined by the state table to be described below. 
<BR><BR>If we assume the control variables to be k.sub.u -the length of the U 
registers and k.sub.l -the length of the L registers. Then .DELTA.=k.sub.u 
-k.sub.l. The values k.sub.l and k.sub.u are implemented with synchronous 
countdown counters, and .DELTA. is implemented with a synchronous up/down 
counter. Counter registers k.sub.u, k.sub.l and .DELTA. are also provided. The 
UL and LL registers are left shift registers while the UR and LR registers are 
both left and right shift registers. <BR><BR>Furthermore, for the count 
registers, .DELTA. is loaded with 0, K.sub.u is initialized to M. A control bit 
latch provides a toggle function wherein a "1" designates an up count and a "0" 
designates a down count. The U/D control is initially set to "1." Then a 
sequencer contained in the controller for performing the inversion in the ALU 
has the following outputs: <BR><BR>deckl . . . Decrement K.sub.l <BR><BR>decku . 
. . Decrement K.sub.u <BR><BR>deDelta . . . Decrement .DELTA. <BR><BR>incDelta . 
. . Increment .DELTA. <BR><BR>toggle . . . Toggle UP/DOWN <BR><BR>lsUL . . . 
left-shift Upper Left register <BR><BR>lsLL . . . left-shift Lower Left register 
<BR><BR>lsUR . . . left-shift Upper Right register <BR><BR>lsLR . . . left-shift 
Lower Right register <BR><BR>rsUR . . . right-shift Upper Right register 
<BR><BR>rsLR . . . right-shift Lower Right register <BR><BR>outLR . . . Output 
Lower Right register <BR><BR>outUR . . . Output Upper Right register 
<BR><BR>dadd-lsLL . . . Down XOR and left-shift Lower Left register 
<BR><BR>uadd-lsUL . . . Up XOR and left-shift Upper Left register <BR><BR>A 
state table outlining the action of the inverter follows as TABLE 1, wherein 
M.sub.u and M.sub.l are the upper bit of registers UL and LL respectively and 
wherein M.sub.u and M.sub.l determine the current state. When an action is 
performed on the registers and counters which places the inverter in a new 
state. The process is repeated until either K.sub.u or K.sub.l are zero and one 
of the right register RL or RU will contain g.sup.-1. <BR><BR><PRE>    TABLE 1
    U/D    K.sub.u  K.sub.l  .DELTA. M.sub.u  M.sub.l  Action
    X      0      X    X    X      X    OutLR
    X      X      0    X    X      X    OutUR
    1      0      0    0    0      1    Deck.sub.u dec .DELTA. lsUL lsURtoggle
    1      0      0    0    0      1    Deck.sub.u dec .DELTA. lsUL rsLR
    0      0      0    X    0      1    Deck.sub.u dec .DELTA. lsUL lsUR
    0      0      0    0    1      0    Deck.sub.l inc .DELTA. lsLL lsLR toggle
    0      0      0    0    1      0    Deck.sub.l inc .DELTA. lsLL rsUR
    1      0      0    X    1      0    Deck.sub.l inc .DELTA. lsLL lsLR
    0      0      0    0    1      1    Deck.sub.l inc .DELTA. Dadd-lsLL lsLR
     toggle
    0      0      0    0    1      1    Deck.sub.l inc .DELTA. Dadd-lsLL rsUR
    1      0      0    0    1      1    Deck.sub.u dec .DELTA. Uadd-lsUL lsUR
     toggle
    1      0      0    0    1      1    Deck.sub.u dec .DELTA. Uadd-lsUL rsLR
</PRE><BR><BR>Integer arithmetic <BR><BR>The extreme similarity of polynomial 
and integer representations for allows for the sharing of hardware in the ALU. 
For addition, the integer arithmetic is only complicated by the requirement for 
carries. The integer arithmetic operations of the ALU are best illustrated by 
way of example utilizing a multiplication operation. <BR><BR>Multiplication in Z 
is illustrated by way of reference to the following sequence of steps 
represented in pseudo-code, wherein as earlier, a and b are bit vectors to be 
multiplied and c is the product of a and b, and wherein c=(c.sub.0, c.sub.1, . . 
. c.sub.n-1). <BR><BR>C=0 <BR><BR>M=0 <BR><BR>For i from 0 to n-1 do 
<BR><BR>C.sup.ext.rarw.C <BR><BR>For j from 0 to n-1 do <BR><BR>cj=(b.sub.i 
(a.sub.j)+m.sub.j +c.sub.j)mod 2 <BR><BR>m.sub.j +1=(b.sub.j (a.sub.j)+m.sub.j 
+c.sub.j)/2 <BR><BR>And where <BR><BR>C.sup.ext.rarw.C: For j from n-1 to 0 do 
<BR><BR>c.sub.j-1 =c.sub.j <BR><BR>c.sub.j-1.sup.ext =c.sub.j.sup.ext <BR><BR>It 
may be observed that the bit-slices 70 for finite field multiplication 
illustrated in the embodiment of FIG. 6, may be modified to include 
multiplication for integer representations. It may also be noted that for 
integer multiplication, the registers are loaded with the bit vectors in reverse 
order i.e. the leftmost cell of a register contains the LSB of the bit vector. 
In integer number multiplication, it is necessary to implement carries between 
successive partial products, furthermore as the partial products are not being 
reduced by a modulus the carries from the addition of successive partial 
products must be provided for. Thus the accumulator register C is extended and a 
new register C.sup.ext 49 is provided as shown in FIG. 5. Before each partial 
product is formed, the lowest bit of the accumulator C (cell C.sub.M) is shifted 
into the topmost bit of the extension register C.sup.ext (cell C.sup.ext.sub.1) 
and then both the accumulator C and C.sup.ext are shifted toward the LSB by one 
bit. The final result is obtained in C and C.sup.ext, wherein C.sup.ext contains 
the low order bits of the product. This is represented by the operation 
C.sup.ext.rarw.C above. <BR><BR>Referring now to FIG. 8, a bit-slice 170 is 
shown, and which is similar to the bit-slice 70 of FIG. 6. Accordingly the 
reference numerals used in the description of FIG. 6 will be used to identify 
like components with a prefix 100 added i.e. reference numeral 70 will become 
170. The arrangement of FIG. 8 differs from FIG. 6 in two important ways; the 
modulus register m is used as a carry register, and a mode selection signal 
Z/F.sub.2.sup.M 171 is provided. <BR><BR>Now the terms c.sub.j =c.sub.j-1 
+b.sub.i (a.sub.i)+c.sub.n-1 (m.sub.j) are implemented as before for the finite 
field multiplication with the product of the control signal b.sub.m and the 
contents of register cell A.sub.i, implemented by AND gate 172. The output 174 
of the AND gate 172 is XORed with the contents of register cell c.sub.j-1 by XOR 
gate 176 to produce an output term c.sub.j-1 +b.sub.i (a.sub.i) indicated by 
numeral 158. This output signal is XORed using XOR gate 184 with the term 
"c.sub.n-1 (m.sub.j)" indicated by numeral 185, derived from the AND gate 160 to 
produce the term c.sub.j. In addition, a carry term m.sub.i is produced from the 
sum of the respective products "b.sub.i (a.sub.i). c.sub.j-1 " 162 and 
"(c.sub.j-1 +b.sub.i (a.sub.i)).(m.sub.j)" 163 and written into cell m.sub.i 
182. The product terms 162 and 163 are implemented by AND gates 164 and 166 
respectively. The sum of the terms 162 and 163 are implemented by OR gate 167. 
<BR><BR>The mode selection signal Z/F.sub.2.sup.M 171, is ORed with the carry 
input signal c.sub.n 180 and is also ANDed 168 with clock signal 169. Thus by 
setting Z/F.sub.2.sup.M =0, will implement finite field arithmetic and by 
setting Z/F.sub.2.sup.M =1 will implement integer arithmetic. <BR><BR>Thus the 
modifications necessary to convert the finite field multiplier given previously 
in FIG. 6 into a combined finite field/integer multiplier are shown in FIG. 8. 
Note that the output register C is extended to collect the low order bits of the 
multiplication. As computations in Z are performed without a modulus, the 
modulus register M is not used to reduce the partial products but as a holder of 
the carries. The control signal Z/F.sub.2.sup.M 171 enables the integer 
multiplication circuitry for the ALU. <BR><BR>A final carry propagation may be 
provided by a Manchester ripple chain, possibly extended by a carry-skip 
mechanism of one or two layers owing to the long register length. It is also 
possible to clock for n more cycles, allowing the carry save adders to 
completely merge the carries. <BR><BR>Two's complement subtraction can be 
implemented in the carry propagation adder provided that one input can be 
conditionally complemented at its input and that a "hot" carry-in is made at the 
LSB of the adder. <BR><BR>When multiplying, the ripple-carry will be intolerable 
even if improved by the carry-skip, but this carry propagation can be almost 
entirely removed by using a carry-save adder, which provides a redundant 
representation of the partial product, which is only resolved after the 
multiplication is complete. <BR><BR>In a further embodiment the ALU 4 may be 
modified to provide a linear increase in computation speed as shown in FIG. 9. 
This is achieved by processing consecutive bits from the special-purpose 
registers 16' at once, and implementing additional circuitry indicated by the 
modified sub ALU's 190 to process the incremental additions as schematically 
illustrated in FIG. 9. Processing multiple bits then results in a linear 
increase in speed. For example, where a computation is performed sequentially 
two or more steps in the sequence may be performed simultaneously. In this case 
the controller 20' will process two or more control bits 194 from the 
special-purpose registers 16', and the inputs 192 to the controller are 
indicated in FIG. 9 as multi-bit lines. <BR><BR>A circuit diagram of a two-bit 
at a time multiplier for finite fields is shown in FIG. 10. In this 
implementation, the bit-slices 200 have twice the number of XOR gates 210, 
implementing two terms of the addition, the circuit takes two bits of 
multipliers and adds in two adjacent shifts of the multicand a.sub.i and 
a.sub.i-1, and reduces with two adjacent shifts of the modulus M.sub.i and 
M.sub.i-1. This has the effect of simultaneously producing two consecutive 
partial products with modulus reduction, thus halving the total computation 
time. <BR><BR>It should also be noted that the top-bits of the special-purpose 
registers are used as control bits for the controllers 20' or 20. This has the 
advantage that when the operands are loaded into the registers, they are aligned 
left; thus control is always obtained from a fixed bit location. However, other 
bits may be used as a control bits, e.g. the bottom bits; however, this may 
additionally increase the complexity of the hardware. <BR><BR>Again, multi-bit 
operation potentially providing improved linear increase in computation speed, 
since such options as Booth (or modified-Booth) recoding become possible. 
<BR><BR>It is assumed that the ALU will also be able to perform simple 
arithmetic operations on general registers. An alternative is to have all 
arithmetic performed on ALU internal registers, with the general-purpose 
registers able only to read and write these registers. <BR><BR>The functionality 
of the ALU will include integer addition, utilizing some carry propagation 
method, such as a ripple carry or the combination of carry skip addition and 
carry completion. <BR><BR>The ALU will also provide simple XOR functionality for 
use in finite field addition. Since the integer and finite field representations 
(bit orders) are reversed, it is beneficial to provide a bit reversal mechanism 
for use in field to integer and integer to field conversions. The tops of two 
shift registers are connected to provide for this facility in n clock cycles, 
where n is the length of the arithmetic operands. <BR><BR>The general 
architecture given here has the potential not only to share the register file 
between EC and modular exponential arithmetic, but also to share special purpose 
registers and even combinational logic, in addition to shared control registers. 
<BR><BR>More particularly, the invention is embodied as a circuit and method for 
multiplying two finite field elements over the field F(2.sup.m). A finite field 
that contains 2.sup.m elements is conveniently represented in a binary element 
containing m bits. A finite field element is any collection of m bits, where 
each bit can be either 0 or 1. The m bits of the finite field element can 
represent any of a number of things, depending on the specific implementation of 
the system. Two possible examples are integers and polynomials. <BR><BR>An 
integer represented in binary is a representation well known in the art. Much 
like the base 10 (decimal) system, integers are represented in base 2 (binary) 
as well. For example, the decimal number 12 is represented in binary as the 
string of bits "1100". The least significant bit holds the 1's place. The next 
bit holds the 2's place. The next bits hold the 4's and 8's place, respectively. 
This particular finite field contains 4 bits, thus the field contains a maximum 
of 2.sup.4 =16 elements. It is commonly understood that a 4-bit binary integer 
can range from 0 to 15. A mathematical way to represent this exemplary finite 
field is shown below. <BR><BR>12=1100=1*(8)+1*(4)+0*(2)+0*(1) 
<BR><BR>=1*(23)+1*(22)+0*(21)+0*(20) <BR><BR>A collection of m bits can also 
represent a polynomial, where the bits are the ordered set of coefficients of 
the polynomial. For example, the 3-bit polynomial (x.sup.2 +1) can be 
represented by (101). Since the finite field element is a collection of binary 
bits (called "characteristic 2"), the coefficients of the polynomial must be 0 
or 1. Mathematical functions like addition and multiplication are defined over 
polynomials just as they are for integers. Addition of two polynomials is very 
easy, especially if the coefficients are limited to the values 0 and 1. In the 
example shown below, all coefficients are reduced modulo 2, since the finite 
field has characteristic 2. <BR><BR>First, consider the following polynomials: 
<BR><BR>(x.sup.2 +x+0)+(0+x+1)=(x.sup.2 +2x+1)=(x.sup.2 +0x+1)=(x.sup.2 +1) 
<BR><BR>These polynomials may be represented in binary fields as follows: 
<BR><BR>(1 1 0)+(0 1 1)=(1 2 1)=(1 0 1)=(x.sup.2 +1) <BR><BR>Notice that the 
result of (A+B)=(A XOR B). Thus, addition of polynomials in characteristic 2 is 
equivalent to a bitwise XOR. <BR><BR>If the finite field is characteristic 2, 
subtraction is also done using XOR. This result derives from the fact that 
coefficients are reduced modulo 2. <BR><BR>Multiplication is more complex, but 
has a regular structure that can be exploited in hardware. This is described in 
more detail below. <BR><BR>Multiplication within a finite field must be a 
"closed" operation, otherwise it would no longer be a finite field. Take for 
example multiplying the two 3-bit polynomials shown above. This creates an 
x.sup.3 term, which has no representation in our exemplary 3-bit system. 
<BR><BR>(x.sup.2 +x+0)*(0x+1)=(x.sup.3 +2x.sup.2 +x) !!! CANNOT REPRESENT !!! 
<BR><BR>To solve this problem, the results are reduced modulo another 
polynomial. This other polynomial is commonly called the "irreducible 
polynomial," and is analogous to the modulus in ordinary integer arithmetic. The 
number 12 is represented by (1100) in binary integers, and if 12 is multiplied 
by 3, the result is 36, which is too large to represent with 4 bits. The result, 
36, can be reduced modulo 16. So, 36% 16 is equal to 4. Therefore 
(1100)*(0011)=(0100), modulo 16. In this case, 16 is the modulus. <BR><BR>The 
problem that this invention solves is the computing of A*B mod M, where A and B 
are binary polynomials, and M is another binary polynomial called the 
"irreducible polynomial." <BR><BR>A naive approach would be to brute force 
multiply A by B, store it into a wide register, then perform the reduction. This 
would result in extremely large register sizes, yielding an impractical 
implementation. However, the invention performs built-in modular reduction by M 
during the multiplication. The wide register from the impractical example would 
require 2m bits, if A and B are both m bits wide. The invention performs the 
multiplication and reduction with no extra bits required for an intermediate 
result, and no loss of precision which is unacceptable when dealing with 
symmetric coding systems. <BR><BR>The novel multiplier takes bits of B, one at a 
time, and multiplies it by all bits of A. This is analogous to creating a 
partial product in ordinary integer multiplication. The current partial product 
is then added to a 1-bit shifted version of the previous partial product. Then, 
if the current partial product (accumulator) has a 1 in its most significant 
bit, the entire M value is subtracted from the partial product (this is the 
reduction step). After subtraction, the partial product is guaranteed to be less 
than the irreducible polynomial. As note before, subtraction in characteristic 2 
is equivalent to addition, which is an XOR function. The basic algorithm 
described can be represented by the following pseudo-code: <BR><BR>C=0 
<BR><BR>m="field size in bits" <BR><BR>for (i=m-1 downto 0) <BR><BR>for m=m-1 
downto 0) <BR><BR>C(j)=(((B(i)*A(j))+C(j-1))+(C(m)*M(j))) <BR><BR>Note that the 
* is a 1-bit binary multiplication, equivalent to an AND function, and the + is 
a 1-bit binary addition, equivalent to an XOR function. <BR><BR>Referring to 
FIG. 11, the illustration shows a structure of a circuit that performs finite 
field multiplication as described in the preceding text. <BR><BR>In this 
example, assume that each register 1102, 1104, 1106, 1108 contains m bits. All 
registers are capable of left-shifting. Also, each bit of the registers 
communicates with its neighboring bits, e.g., in each cell (bit-slice), a single 
bit of A, M, and C are stored. The ith bit of A is ANDed with the most 
significant bit of B, and then added to the (i-1)th bit of C. This is equivalent 
to multiplying all of A by 1 bit of B and accumulating with a shifted version of 
C. Then, the ith bit of M is conditionally subtracted from this intermediate 
result if the most significant (nth) bit of C is a 1. Note again that 
subtraction equals addition in characteristic 2, thus the subtractor is simply 
an XOR gate. The most significant bit of C indicates whether a reduction by M 
must occur. <BR><BR>This circuit has considerable flexibility. The registers A, 
B, M, and C are each 256 bits wide. Thus, multiplications of up to 256 bits are 
supported. However, the circuit is flexible enough to handle multiplications 
less than 256 bits, in increments of 1. As long as the data is written 
left-aligned into the registers, with the most significant bit occupying the 
leftmost position, and zero-padded to the right, this circuit will efficiently 
compute the finite field multiplication. <BR><BR>Finite field multiplication is 
critical to the elliptic curve cryptosystem. It is the lowest-level non-trivial 
function that must be computed, therefore improvements to the art such as this 
invention have a direct, noticeable impact on system performance. 
<BR><BR>Referring to FIG. 12, the block diagram shows a finite field data unit 
1204, a finite field control unit 1202, and an interface unit 1208. <BR><BR>The 
finite field data unit 1204 contains the 4 registers. The finite field control 
unit 1202 contains a state machine, and the interface unit 1208 is preferably a 
256-bit register that preferably translates a narrow 32-bit interface to a 
256-bit parallel interface for the finite field data unit 1204. Data can be read 
and written from the registers through the interface unit 1208. When the 
registers are written and properly aligned, the finite field control unit 1202 
is instructed to "GO", causing the multiplication to proceed until finished. 
Basically, each bit of B is tested, starting with the MSB, and the operands are 
shifted, until the full multiplication is complete. <BR><BR>Referring to FIG. 
13, the illustration shows a structure of the finite field data unit 1204. The 4 
registers 1302, 1304, 1306, 1308 in this finite field data unit 1204 correspond 
with the registers 1102, 1104, 1106, 1108 illustrated in FIG. 11. This more 
detailed representation shows a 256 bit data path 1310 and the single bit slice 
1312 as part of a shift register file 1314. <BR><BR>Referring to FIG. 14, the 
illustration shows a block diagram of the finite field control unit 1202. 
<BR><BR>The control port 1408 exists so that the user can initiate a 
multiplication. Upon initiation, the control register 1402 or microsequencer is 
instructed to perform a multiply operation. A start signal 1412 is issued to a 
finite state machine 1404, which outputs the control signals 1410 for the finite 
field data unit. Once per cycle, the registers 1302, 1304, 1306, 1308 are 
shifted to the left (LSB to MSB), and new data is computed/latched into the C 
register. When all bits of B have been used, the multiplication is complete, and 
the done signal 1414 is asserted by the state machine, at which time the process 
stops. <BR><BR>Details relating to the control register or microsequencer are 
omitted, as they are conventional element that are well known in the art. 
<BR><BR>While the invention has been described in connection with a specific 
embodiment thereof and in a specific use, various modifications thereof will 
occur to those skilled in the art without departing from the spirit of the 
invention. For example it may be noted that in the embodiments described, 
reference is made to specific logic circuits, however equivalent circuits may be 
used, for example by using de Morgans Rule or if inverted logic is implemented 
then complementary circuits may be used. In addition, when referring to the 
orientation of the registers and bit vectors, i.e., left, right, top, bottom, 
other arrangements of these directions are also implied. <BR><BR>The terms and 
expressions which have been employed in the specification are used as terms of 
description and not of limitations, there is no intention in the use of such 
terms and expressions to exclude any equivalents of the features shown and 
described or portions thereof, but it is recognized that various modifications 
are possible within the scope of the invention. <BR><BR>
<CENTER><B>* * * * *</B></CENTER>
<HR>

<CENTER><!-- <A HREF=""><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A> --><A 
href="http://patimg2.uspto.gov/.piw?Docid=06230179&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO1%2526Sect2%3DHITOFF%2526d%3DPALL%2526p%3D1%2526u%3D%2Fnetahtml%2Fsrchnum.htm%2526r%3D1%2526f%3DG%2526l%3D50%2526s1%3D6230179.WKU.%2526OS%3DPN%2F6230179%2526RS%3DPN%2F6230179&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=2525F81E1B7C"><IMG 
alt=[Image] src="United States Patent 6,230,179.files/image.gif" border=0 
valign="middle"></A> 
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6230179.WKU.%26OS%3DPN%2F6230179&amp;backLabel1=Back%20to%20Document%3A%206,230,179"><IMG 
      alt="[View Shopping Cart]" 
      src="United States Patent 6,230,179.files/cart.gif" border=0 
      valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,230,179&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6230179.WKU.%26OS%3DPN%2F6230179&amp;backLabel1=Back%20to%20Document%3A%206,230,179"><IMG 
      alt="[Add to Shopping Cart]" 
      src="United States Patent 6,230,179.files/order.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=6230179.WKU.&amp;OS=PN/6230179&amp;RS=PN/6230179#top"><IMG 
      alt=[Top] src="United States Patent 6,230,179.files/top.gif" border=0 
      valign="middle"></A> </TD></TR></TBODY></TABLE><A name=bottom></A><A 
href="http://www.uspto.gov/patft/index.html"><IMG alt=[Home] 
src="United States Patent 6,230,179.files/home.gif" border=0 
valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
alt="[Boolean Search]" src="United States Patent 6,230,179.files/boolean.gif" 
border=0 valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG alt="[Manual Search]" 
src="United States Patent 6,230,179.files/manual.gif" border=0 
valign="middle"></A> <A href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG 
alt="[Number Search]" src="United States Patent 6,230,179.files/number.gif" 
border=0 valign="middle"></A> <A 
href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
src="United States Patent 6,230,179.files/help.gif" border=0 
valign="middle"></A> </CENTER></BODY></HTML>
