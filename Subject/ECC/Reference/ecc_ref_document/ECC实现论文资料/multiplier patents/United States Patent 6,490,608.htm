<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0157)http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=/netahtml/srchnum.htm&r=1&f=G&l=50&s1=6490608.WKU.&OS=PN/6490608&RS=PN/6490608 -->
<HTML><HEAD><TITLE>United States Patent: 6,490,608</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content="MSHTML 6.00.2800.1505" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff><A name=top></A>
<CENTER><IMG 
alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" 
src="United States Patent 6,490,608.files/patfthdr.gif"> <BR><!-- <IMG border=0 src=/netaicon/PTO/titlebar.gif><br> -->
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A href="http://www.uspto.gov/patft/index.html"><IMG 
      alt=[Home] src="United States Patent 6,490,608.files/home.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
      alt="[Boolean Search]" 
      src="United States Patent 6,490,608.files/boolean.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG 
      alt="[Manual Search]" 
      src="United States Patent 6,490,608.files/manual.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG 
      alt="[Number Search]" 
      src="United States Patent 6,490,608.files/number.gif" border=0 
      valign="middle"></A> <A 
      href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
      src="United States Patent 6,490,608.files/help.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=6490608.WKU.&amp;OS=PN/6490608&amp;RS=PN/6490608#bottom"><IMG 
      alt=[Bottom] src="United States Patent 6,490,608.files/bottom.gif" 
      border=0 valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6490608.WKU.%26OS%3DPN%2F6490608&amp;backLabel1=Back%20to%20Document%3A%206,490,608"><IMG 
      alt="[View Shopping Cart]" 
      src="United States Patent 6,490,608.files/cart.gif" border=0 
      valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,490,608&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6490608.WKU.%26OS%3DPN%2F6490608&amp;backLabel1=Back%20to%20Document%3A%206,490,608"><IMG 
      alt="[Add to Shopping Cart]" 
      src="United States Patent 6,490,608.files/order.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patimg1.uspto.gov/.piw?Docid=06490608&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO1%2526Sect2%3DHITOFF%2526d%3DPALL%2526p%3D1%2526u%3D%2Fnetahtml%2Fsrchnum.htm%2526r%3D1%2526f%3DG%2526l%3D50%2526s1%3D6490608.WKU.%2526OS%3DPN%2F6490608%2526RS%3DPN%2F6490608&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=086A6F8D0A8A"><IMG 
      alt=[Image] src="United States Patent 6,490,608.files/image.gif" border=0 
      valign="middle"></A> <!-- <A HREF=""><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A>
<BR><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ULL </FONT><FONT SIZE=4 COLOR="#CC3300">T</FONT><FONT SIZE=2 COLOR="#CC3300">EXT </FONT><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ORMAT</FONT></STRONG> --></TD></TR></TBODY></TABLE></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%">&nbsp;</TD>
    <TD vAlign=bottom align=right width="50%"><FONT size=-1>( 
      <STRONG>1</STRONG></FONT> <FONT size=-2>of</FONT> <STRONG><FONT 
      size=-1>1</STRONG> )</FONT></TD></TR></TBODY></TABLE>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%"><B>United States Patent </B></TD>
    <TD align=right width="50%"><B><B><I>6,490,608</I></B> </B></TD></TR>
  <TR>
    <TD align=left width="50%"><B>Zhu </B><!-- 2: Zhu; Jay
,
,
,
<br>Zhu, ;, , ,  --></TD>
    <TD align=right width="50%"><B>December 3, 2002 </B></TD></TR></TBODY></TABLE>
<HR>
<FONT size=+1>Fast parallel multiplier implemented with improved tree reduction 
schemes </FONT><BR><BR>
<CENTER><B>Abstract</B></CENTER>
<P>Parallel multipliers and techniques for reducing Wallace-trees in parallel 
multipliers to achieve fewer reduction stages. The parallel multipliers of the 
present invention, in one embodiment, require one fewer stage of reduction than 
conventional multipliers proposed by Wallace and Dadda. Accordingly, fewer adder 
components are required. The speed of the parallel multipliers of the present 
invention is also improved due to the fewer number of reduction stages. In 
another embodiment, the method of the present invention is applicable to signed 
multiplication and includes a step of performing trial reduction on an input 
matrix that has a maximum number of nodes per column K. The trial reduction step 
is performed with a reduction target of .delta..sub.L-2 nodes where 
.delta..sub.L-1 &lt;K.ltoreq..delta..sub.L. If maximum number of nodes per 
column in the resulting matrix does not exceed .delta..sub.L-2, then reduction 
steps are performed to generate a reduction tree having L-1 reduction stages. 
Otherwise, reduction steps are performed to generate a reduction tree having L 
stages. Further, in one embodiment of the present invention, the reduction tree 
T is then reduced such that as many LSBs (least significant bits) of the tree T 
at the final stage have at most one node and that the bit adjacent to the LSBs 
has at most three nodes. In furtherance of the present invention, run-time 
performance of the present invention is improved when extra nodes at lower and 
upper edge of the input matrix T may be ignored during reduction. </P>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="10%">Inventors: </TD>
    <TD align=left width="90%"><B>Zhu; Jay</B> (Fremont, CA) </TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Assignee: </TD>
    <TD align=left width="90%"><B>Synopsys, Inc.</B> (Mountain View, CA) 
</TD></TR>
  <TR>
    <TD vAlign=top noWrap align=left width="10%">Appl. No.: </TD>
    <TD align=left width="90%"><B>458542</B></TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Filed: </TD>
    <TD align=left width="90%"><B>December 9, 1999</B></TD></TR></TBODY></TABLE>
<P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Current U.S. Class:</B></TD>
    <TD vAlign=top align=right width="60%"><B>708/626</B> </TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Intern'l Class: </B></TD>
    <TD vAlign=top align=right width="60%">G06F 007/52</TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Field of Search: </B></TD>
    <TD vAlign=top align=right width="60%">708/626,628,629 
</TD></TR></TBODY></TABLE>
<HR>

<CENTER><B>References Cited <A 
href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=CR02&amp;Query=ref/6,490,608">[Referenced 
By]</A></B></CENTER>
<HR>

<CENTER><B>U.S. Patent Documents</B></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5586071">5586071</A></TD>
    <TD width="25%">Dec., 1996</TD>
    <TD align=left width="25%">Flora</TD>
    <TD align=right width="25%">708/626. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5798956">5798956</A></TD>
    <TD width="25%">Aug., 1998</TD>
    <TD align=left width="25%">Park</TD>
    <TD align=right width="25%">708/626. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5978827">5978827</A></TD>
    <TD width="25%">Nov., 1999</TD>
    <TD align=left width="25%">Ichikawa</TD>
    <TD align=right width="25%">708/626. </TD></TR></TBODY></TABLE><BR>
<TABLE width="90%"><BR>
  <CENTER><B>Other References</B></CENTER>
  <TBODY>
  <TR>
    <TD align=left><BR>Amos R. Omondi, "Computer Arithmetic Systems: 
      Algorithms, Architecture and Implementation", 1994, Prentice Hall 
      International (UK), pp. 126-129, 160-171. <BR>L. Dadda, "Some Schemes for 
      Parallel Multipliers", 1965, Instituto di Elettrotecnica ed Electtronica 
      del Politecnico di Milano, pp. 349-356. <BR>Israel Koren, "Computer 
      Arithmetic Algorithms", 1993, Prentice-Hall, Inc., pp. 86-92, 108-111. 
  </TD></TR></TBODY></TABLE><BR><I>Primary Examiner:</I> Malzahn; David H. 
<BR><I>Attorney, Agent or Firm:</I> Wagner Murabito &amp; Hao LLP <BR>
<HR>

<CENTER><B><I>Claims</B></I></CENTER>
<HR>
<BR><BR>What is claimed is: <BR><BR>1. A method of constructing a parallel 
multiplier comprising the steps of: <BR><BR>a) constructing an input matrix for 
said parallel multiplier; <BR><BR>b) determining a depth K of said input matrix; 
<BR><BR>c) calculating maximum stage capacity numbers for said input matrix, 
said maximum stage capacity numbers comprising .delta..sub.L-1 and 
.delta..sub.L, wherein .delta..sub.L-1 denotes a maximum stage capacity at a 
stage (L-1) and .delta..sub.L denotes a maximum stage capacity at a stage L 
wherein .delta..sub.L-1 &lt;K.ltoreq..delta..sub.L ; <BR><BR>d) determining 
whether said input matrix is reducible within (L-1) reduction stages; and 
<BR><BR>e) provided that said input matrix is reducible within (L-1) reduction 
stages, constructing a first reduction tree having (L-1) reduction stages for 
said parallel multiplier. <BR><BR>2. A method as recited in claim 1 further 
comprising the step of generating a netlist of said parallel multiplier based on 
said first reduction tree. <BR><BR>3. A method as recited in claim 1 wherein 
said step (d) comprises the step of attempting to reduce said input matrix to a 
trial reduction matrix having a depth of .delta..sub.L-2. <BR><BR>4. A method as 
recited in claim 1 further comprising the steps of: <BR><BR>g) provided that 
said input matrix is not reducible within (L-1) reduction stages, constructing a 
second reduction tree having L reduction stages; and <BR><BR>h) generating a 
netlist of said parallel multiplier based on said second reduction tree. 
<BR><BR>5. A method as recited in claim 1 wherein said step (d) comprises the 
steps of: <BR><BR>determining whether said depth K of said input matrix is 
equivalent to .delta..sub.L-1 +1; <BR><BR>determining whether an extra node 
occurs on a low edge of said input matrix; and <BR><BR>determining whether an 
extra node occurs on a high edge of said input matrix. <BR><BR>6. A method as 
recited in claim 1 wherein an output array of said first reduction tree includes 
a plurality of least significant bits each having a single node. <BR><BR>7. A 
method as recited in claim 6 wherein a bit of said output array adjacent to said 
plurality of least significant bits comprises at most three nodes. <BR><BR>8. A 
method as recited in claim 1 wherein said step (b) comprises a step of counting 
a maximum number of nodes per column of said input array. <BR><BR>9. A 
computer-readable medium having contained therein computer-readable codes for 
causing a computer-implemented logic synthesis system to perform a method of 
constructing a parallel multiplier, the method comprising the steps of: 
<BR><BR>a) constructing an input matrix for said parallel multiplier; <BR><BR>b) 
determining a depth K of said input matrix; <BR><BR>c) calculating maximum stage 
capacity numbers for said input matrix, said maximum stage capacity numbers 
comprising .delta..sub.L-1 and .delta..sub.L, wherein .delta..sub.L-1 denotes a 
maximum stage capacity at a stage (L-1) and .delta..sub.L denotes a maximum 
stage capacity at a stage L and further wherein .delta..sub.L-1 
&lt;K.ltoreq..delta..sub.L ; <BR><BR>d) determining whether said input matrix is 
reducible within (L-1) reduction stages; and <BR><BR>e) provided that said input 
matrix is reducible within (L-1) reduction stages, generating a netlist of a 
first reduction tree having (L-1) reduction stages for said parallel multiplier. 
<BR><BR>10. A computer-readable medium as recited in claim 9 wherein said method 
further comprises the step of generating a netlist of said parallel multiplier 
based on said first reduction tree. <BR><BR>11. A computer-readable medium as 
recited in claim 9 wherein said step (d) of said method comprises the step of 
attempting to reduce said input matrix to a trial reduction matrix having a 
depth of .delta..sub.L-2. <BR><BR>12. A computer-readable medium as recited in 
claim 9 wherein said method further comprises the steps of: <BR><BR>g) provided 
that said input matrix is not reducible within (L-1) reduction stages, 
generating a netlist of a second reduction tree having L reduction stages; and 
<BR><BR>h) generating a netlist of said parallel multiplier based on said second 
reduction tree. <BR><BR>13. A computer-readable medium as recited in claim 9 
wherein said step (d) of said method comprises the steps of: <BR><BR>determining 
whether said depth K of said input matrix is equivalent to .delta..sub.L-1 +1; 
<BR><BR>determining whether an extra node occurs on a low edge of said input 
matrix; and <BR><BR>determining whether an extra node occurs on a high edge of 
said input matrix. <BR><BR>14. A computer-readable medium as recited in claim 9 
wherein an output array of said first reduction tree includes a plurality of 
least significant bits each having a single node. <BR><BR>15. A 
computer-readable medium as recited in claim 14 wherein a bit of said output 
array adjacent to said plurality of least significant bits comprises at most 
three nodes. <BR><BR>16. A computer-readable medium as recited in claim 9 
wherein said step (b) of said method comprises a step of counting a maximum 
number of nodes per column of said input array. <BR><BR>17. A parallel 
multiplier comprising: <BR><BR>a first input for receiving a first operand and a 
second input for receiving a second operand; <BR><BR>a partial product generator 
for generating an input array of partial products, wherein said input array has 
a depth of K nodes; <BR><BR>a reduction tree structure for reducing said input 
array, said reduction tree structure having (L-1) reduction stages, wherein said 
depth K of said input array is larger than a predefined maximum stage capacity 
.delta..sub.L-1 ; and <BR><BR>a carry propagation adder for summing an output 
array generated by said reduction tree structure to generate a final product. 
<BR><BR>18. A parallel multiplier as recited in claim 17 wherein said reduction 
tree structure comprises a plurality of full adders and a plurality of half 
adders. <BR><BR>19. A parallel multiplier as recited in claim 17 wherein said 
output array includes a plurality of bits that are directly mapped to said final 
product. <BR><BR>20. A parallel multiplier as recited in claim 17 wherein a 
carry input of said carry propagation adder receives a bit of said output array. 
<BR><BR>21. A parallel multiplier as recited in claim 17 wherein a final 
reduction stage of said reduction tree structure includes a plurality of least 
significant bits each having a single node. <BR><BR>22. A parallel multiplier as 
recited in claim 21 wherein a bit of said final reduction stage of said 
reduction tree structure comprises at most three nodes. 
<HR>

<CENTER><B><I>Description</B></I></CENTER>
<HR>
<BR><BR>FIELD OF THE INVENTION <BR><BR>The present invention relates generally 
to the field of hardware used for performing computer arithmetic operations. 
More specifically, the present invention pertains to circuits capable of 
performing arithmetic operations on operands of signed and non-signed binary 
values. <BR><BR>BACKGROUND OF THE INVENTION <BR><BR>Hardware circuits for 
performing arithmetic operations are indispensable in every computer system, 
cellular phone and most digital audio/video equipment. In real-time applications 
(e.g., simulations, speech recognition, video teleconferencing, computer games, 
streaming audio/video etc.), the overall system performance is heavily dependent 
on the speed of the multipliers. For instance, processing digital images at 30 
frames/second requires nearly 2.2 million multiplication operations per second. 
These systems require multiplication operations be performed at a very high 
speed. <BR><BR>A technique that is commonly used in high-speed multiplier is 
carry-save addition. In carry-save addition, a carry-save adder (CSA) accepts 
three n-bit operands and generates two n-bit results which include an n-bit 
partial sum, and an n-bit carry. A second CSA accepts these two n-bit results 
and another n-bit input operand, and generates a new partial sum and carry. A 
CSA is therefore, capable of reducing the number of operands to be added from 3 
to 2 without any carry propagation. When the number of operands is eventually 
reduced to 2, the operands can be added together with a carry propagate adder 
(CPA). Carry save addition has the advantage of minimizing delay caused by carry 
propagation. <BR><BR>FIG. 1 illustrates a parallel 5-bit-by-5-bit multiplier 
100, which is comprised of CSAs 110, 120 and 130 and CPA 140. CSAs are made up 
of full adders (FA) and half adders (HA). As shown in FIG. 1, each multiplicand 
multiple is denoted by MP.sup.i.sub.j which is obtained as the logical-AND of 
bit i of the multiplier and bit j of the multiplicand. The first-level CSA 110 
is used for the first three multiplicand multiples, and at the next level, CSA 
120 receives the outputs of the first level CSA 110 and adds to them the fourth 
multiplicand multiples. The outputs of the second level CSA 120 are provided to 
the third level CSA 130 adds the fifth multiplicand multiples. The outputs of 
the third level CSA 130 are two numbers which are then summed together by CPA 
140 to generate the final product. This type of parallel multiplier is also 
commonly referred to as parallel-array multipliers: <BR><BR>Another class of 
parallel multiplier, proposed by C.S. Wallace in 1963, and commonly referred to 
as Wallace tree multipliers or simultaneous multipliers, are also commonly used. 
A block diagram of an exemplary six-operand Wallace tree multiplier 200 is 
illustrated in FIG. 2. As shown in FIG. 2, Wallace tree multiplier 200 includes 
CSAs 210, 220, 230 and 240 and CPA 250. The first level CSAs 210 and 220 receive 
the six operands and reduce them two four outputs. The second level CSA 230 
receives the shifted carry output and sum output of the CSA 220 and the sum 
output of CSA 210 and generates two outputs, which are added to the shifted 
carry output of CSA 210 to generate two numbers. The two numbers which are added 
together by CPA 250 to generate the final product. In general, a Wallace tree 
multiplier has fewer levels (or stages) of carry-save adders than a straight 
forward parallel-array multiplier of the same width, and thus, better 
performance. A discussion of the parallel array multipliers and Wallace tree 
multipliers can be found in A. R. Omondi, "Computer Arithmetic Systems: 
Algorithms, Architecture and Implementation," pp. 160-170, 1994. <BR><BR>A 
modification of the Wallace tree multiplier, proposed by L. Dadda in 1965 and 
generally called a Dadda multiplier, has less logic. There also exist a number 
of parallel multipliers in which other counters are used to reduce the depth of 
the tree. This, however, does not necessarily result in proportionate 
improvement in performance because the increase in the complexity of the 
counters also means an increase delay through them. <BR><BR>As the power of 
computer systems, cellular phones, digital A/V equipment etc. continues to 
increase, the demand for faster multipliers is likely to rise. At the same time, 
systems are also becoming increasingly integrated. Designing fast multipliers 
that occupy smaller areas on the integrated circuit (IC) chip is critical to a 
commercially successful product. Therefore, what is needed is a multiplier 
circuit that is faster and smaller. What is further needed is a method of 
reducing reduction trees such that the resulting parallel multiplier circuit 
uses fewer levels of CSA components than conventional multipliers. 
<BR><BR>SUMMARY OF THE DISCLOSURE <BR><BR>Accordingly, the present invention 
provides parallel multipliers that require one fewer stage of reduction than 
conventional multipliers. Accordingly, fewer adder components are required. The 
speed of the parallel multipliers of the present invention is also improved due 
to the fewer number of reduction stages. <BR><BR>The present invention also 
provides a method of constructing reduction trees in parallel multipliers to 
achieve fewer reduction stages. In one embodiment, the method of the present 
invention is applicable to signed multiplication and includes a step of 
generating an input matrix based on the operand sizes, data types, etc., of the 
multiplier; and determining a maximum number of nodes per column (K) of the 
input matrix. The method of the present embodiment also includes the step of 
generating a series of maximum stage capacity numbers .delta..sub.N including 
.delta..sub.L-2, .delta..sub.L-1, and .delta..sub.L where 
.delta..sub.L-1.ltoreq.K.ltoreq..delta..sub.L. The method of the present 
embodiment then performs a step of trial reduction on an input matrix. The trial 
reduction step is performed in an attempt to reduce the maximum number of nodes 
per column of the input matrix to less than or equal to .delta..sub.L-2. If the 
trial reduction step is successful in reducing the input matrix, then reduction 
steps are performed to generate a reduction tree that has L-1 reduction stages. 
Otherwise, reduction steps are performed to generate a reduction tree that has L 
stages. <BR><BR>In comparison to conventional reduction methods, such as those 
proposed by Wallace and Dadda, the present invention generates reduction trees 
that may use one fewer level of reduction stages for the same operands. 
Multipliers having fewer reduction stages would therefore have a smaller delay 
and may also require a smaller die area. <BR><BR>Further, in one embodiment, the 
method of the present invention includes a step of "squeezing" as many LSBs 
(least significant bits) of the output matrix of the reduction tree to at most 
one node. According to the present invention, the single nodes at the output 
matrix can be directly provided to the output of the multiplier without going 
through the final adder. Thus, a smaller final adder would be needed. Benefits 
of the "squeezing" step include (1) speeding up the circuit and (2) reducing the 
size of the circuit. In furtherance of one embodiment of the invention, the bit 
adjacent to the "squeezed" LSBs may have up to three nodes. Significant savings 
in delay and die area can be achieved because the third node may be provided to 
a carry input of the final adder. <BR><BR>Embodiments of the present invention 
include the above and further include a computer-readable medium having 
contained therein computer-readable codes for causing a computer-implemented 
logic synthesis system to perform a method of constructing a parallel 
multiplier. The method of the present embodiment includes the steps of: (a) 
accessing an input matrix; (b) determining a depth K of the input matrix; (c) 
calculating maximum stage capacity numbers for the input matrix. In the present 
embodiment, the maximum stage capacity numbers includes {.delta..sub.N } where 
.delta..sub.N =[.delta..sub.0, . . . .delta..sub.L-2, .delta..sub.L-1, 
.delta..sub.L ]. In accordance with the present embodiment, .delta..sub.L-1 
denotes a maximum stage capacity at a stage (L-1) and .delta..sub.L denotes a 
maximum stage capacity at a stage L. Further, in the present embodiment, 
.delta..sub.L-1 &lt;K.ltoreq..delta..sub.L. The method of the present embodiment 
further includes the steps of: (d) performing a trial reduction using stage 
(L-2) as target stage; (e) provided that a depth of the trial reduction matrix 
does not exceed maximum stage capacity of the stage (L-2), generating a 
reduction tree with (L-1) reduction stages; and (f) generating a netlist of the 
parallel multiplier based on the reduction tree. <BR><BR>BRIEF DESCRIPTION OF 
THE DRAWINGS <BR><BR>The accompanying drawings, which are incorporated in and 
form a part of this specification, illustrate embodiments of the present 
invention and, together with the description, serve to explain the principles of 
the invention. <BR><BR>FIG. 1 illustrates a schematic diagram of a conventional 
5-bit-by-5-bit parallel array multiplier. <BR><BR>FIG. 2 illustrates a schematic 
diagram of a conventional Wallace tree multiplier. <BR><BR>FIG. 3 illustrates a 
computer system operable as a platform on which methods of the present invention 
may be implemented. <BR><BR>FIG. 4A illustrates a logical block diagram of an 
exemplary full adder used in constructing reduction trees of the present 
invention. <BR><BR>FIG. 4B illustrates a logical block diagram of an exemplary 
half adder used in constructing reduction trees of the present invention. 
<BR><BR>FIG. 5 illustrates a process of constructing an exemplary reduction tree 
as proposed by L. Dadda. <BR><BR>FIG. 6 illustrates steps of a tree reduction 
process according to an embodiment of the present invention. <BR><BR>FIG. 7A 
illustrates an exemplary input matrix generated by an input matrix generation 
step in accordance with an embodiment of the present invention. <BR><BR>FIG. 7B 
illustrates an exemplary trial reduction step in accordance with an embodiment 
of the present invention. <BR><BR>FIG. 7C illustrates an exemplary tree 
reduction step in accordance with the present embodiment. <BR><BR>FIG. 8 
illustrates a block diagram of an exemplary parallel multiplier according to an 
embodiment of the present invention. <BR><BR>FIG. 9 illustrates an exemplary 
input matrix that includes an extra "low edge" node and an extra "high edge" 
node. <BR><BR>FIG. 10A is a bit representation of a reduction tree for a 
5-bit-by-5-bit signed multiplier that does not have a column with three rows in 
the final stage. <BR><BR>FIG. 10B is a bit representation of a reduction tree 
for a 5-bit-by-5-bit signed multiplier that has a column with three rows in the 
final stage and uses fewer adders than the reduction tree of FIG. 10A in 
furtherance of an embodiment of the present invention. <BR><BR>FIG. 11A is a bit 
representation of a reduction tree for a 4-bit-by-4-bit signed mutliplier that 
does not have a column with three rows in the final stage. <BR><BR>FIG. 11B is a 
bit representation of a reduction tree for a 4-bit-by-4-bit signed multiplier 
that has a column with three rows in the final stage and requires a shorter CPA 
than the multiplier of FIG. 11A in furtherance of an embodiment of the 
invention. <BR><BR>FIG. 12A is a bit representation of an input matrix for an 
exemplary 5-bit-by-3-bit signed multiplier. <BR><BR>FIG. 12B is a bit 
representation of an input matrix for an exemplary 4-bit-by-4 bit signed 
multiplier. <BR><BR>FIG. 12C is a bit representation of an input matrix for an 
exemplary 5-bit-signed-by-3-bit-unsigned multiplier. <BR><BR>FIG. 12D is a bit 
representation of an input matrix for an exemplary 
5-bit-unsigned-by-3-bit-signed multiplier. <BR><BR>DETAILED DESCRIPTION OF THE 
PREFERRED EMBODIMENTS <BR><BR>In the following detailed description, for 
purposes of explanation, numerous specific details are set forth in order to 
provide a thorough understanding of the present invention. However, it will be 
apparent to one skilled in the art that the present invention may be practiced 
without these specific details. In other instances, well-known structures and 
devices are not described in detail in order to avoid obscuring aspects of the 
present invention. <BR><BR>Some portions of the detailed descriptions which 
follow are presented in terms of procedures, steps, logic blocks, processing, 
and other symbolic representations of operations on data bits within a computer 
memory. These descriptions and representations are the means used by those 
skilled in the data processing arts to most effectively convey the substance of 
their work to others skilled in the art. A procedure, computer executed step, 
logic block, process, etc., is here and generally conceived to be a 
self-consistent sequence of steps of instructions leading to a desired result. 
The steps are those requiring physical manipulations of data representing 
physical quantities to achieve tangible and useful results. It has proven 
convenient at times, principally for reasons of common usage, to refer to these 
signals as bits, values, elements, symbols, characters, terms, numbers or the 
like. <BR><BR>It should be borne in mind, however, that all of these and similar 
terms are to be associated with the appropriate physical quantities and are 
merely convenient labels applied to these quantities. Unless specifically stated 
otherwise as apparent from the following discussions, it is appreciated that 
throughout the present invention, discussions utilizing terms such as 
"accessing", "determining", "generating", "associating", "assigning", or the 
like, refer to the actions and processes of a computer system, or similar 
electronic computing device. The computer system or similar electronic device 
manipulates and transforms data represented as electronic quantities within the 
computer system's registers and memories into other data similarly represented 
as physical quantities within the computer system memories into other data 
similarly represented as physical quantities within the computer system memories 
or registers or other such information storage, transmission, or display 
devices. <BR><BR>Aspects of the present invention are discussed in terms of 
steps executed on a computer controlled EDA (electronic design automation) 
system. These steps are implemented as program code stored in computer readable 
memory units of a computer system and are executed by the processor of the 
computer system. Although a variety of different computer systems can be used 
with the present invention, an exemplary general purpose computer system 312 is 
shown in FIG. 3. <BR><BR>In general, computer system 312 includes an 
address/data bus 300 for communicating information, a central processor 301 
coupled with the bus for processing information and instructions, a volatile 
memory 302 (e.g., random access memory RAM) coupled with the bus 300 for storing 
information and instructions for the central processor 301 and a non-volatile 
memory 303 (e.g., read only memory ROM) coupled with the bus 300 for storing 
static information and instructions for the processor 301. Computer system 312 
also includes a data storage device 304 ("disk subsystem") such as a magnetic or 
optical disk and disk drive coupled with the bus 300 for storing information and 
instructions and a display device 305 coupled to the bus 300 for displaying 
information to the computer user. Data storage device 304 can include one or 
more removable magnetic or optical storage media (e.g., diskettes, tapes) which 
are computer readable memories. It is appreciated that data produced at the 
various logic synthesis stages of the present invention, including 
representations of the different levels of abstraction of the integrated circuit 
design, such as a netlist, can also be stored in RAM 302, ROM 303 or the storage 
device 304. <BR><BR>Also included in computer system 312 of FIG. 3 is an 
optional alphanumeric input device 306 including alphanumeric and function keys 
coupled to the bus 300 for communicating information and command selections to 
the central processor 301. Computer system 312 also includes an optional cursor 
control or directing device 307 coupled to the bus for communicating user input 
information and command selections to the central processor 301. Computer system 
312 can also include an optional communication device (e.g., network interface 
card) 308 coupled to the bus 300 for interfacing with other networked computer 
systems. The display device 305 utilized with the computer system 312 of the 
present invention may be a liquid crystal device, other flat panel display, 
cathode ray tube, or other display device suitable for creating graphic images 
and alphanumeric characters recognizable to the user. <BR><BR>Reduction trees 
according to embodiments of the present invention may be implemented with full 
adders (FA) and/or half-adders (HA). FIG. 4A illustrates a logical block diagram 
of an exemplary full adder 410. As illustrated, FA 410 receives three inputs X, 
Y and Z, and generates thereof two outputs C and F. The FA 410 is also known as 
a (3, 2) counter. A truth table for the FA 410 is shown below in Table 1. 
<BR><BR><PRE>          TABLE 1
          Inputs                   C (carry)      F (sum)
          None of X Y Z is 1           0             0
          One of X Y Z is 1            0             1
          Two of X Y Z are 1           1             0
          All X Y Z are 1              1             1
</PRE><BR><BR>FIG. 4B illustrates a logical block diagram of an exemplary half 
adder 420. HA 420 receives two inputs A and B and generates therefore two 
outputs C and H. HA 420 is also known as a (2, 2) counter. A truth table for HA 
420 is shown below in Table 2. <BR><BR><PRE>          TABLE 2
          Inputs                   C (carry)      H (sum)
          None of A nor B is 1         0             0
          One of A or B is 1           0             1
          Both A and B are 1           1             0
</PRE><BR><BR>Generally, an accepted economical implementation (in terms of 
levels of CSAs used) of a Wallace tree is achieved when the number of operands 
is an element of the series 2, 3, 4, 6, 9, 13, 19, 28, etc. For a given number 
of operands, for instance W, which is not an element of this series, it has been 
proposed that the most economical way to implement the Wallace tree is to use 
only enough CSAs in the top level such that the number of operands in the next 
level coincide with an element of the abovementioned series. For example, if the 
number of operands, W, is 27, then according to the conventional tree reduction 
methods, the most economical implementation is achieved when only enough CSAs 
are used to reduce the number of operands to 19. Then, the remaining part of the 
tree will have its operands follow the abovementioned series. <BR><BR>FIG. 5 
illustrates a process 500 of constructing an exemplary reduction tree as 
proposed in L. Dadda, "Some Schemes for Parallel Multipliers." Alta Frequenza, 
Vol. 34, pp. 349-356, 1965. Particularly, in FIG. 5, an input matrix 510 for a 
5-bit-by-5-bit multiplier is illustrated. Each node of the matrix 510 represents 
a partial product to be added by the multiplier. The input matrix 510 is then 
reduced to a second matrix 520 by a first reduction step 515. Vertical blocks 
512 of FIG. 5 containing three nodes represents inputs of a full adder (e.g., FA 
410) and a vertical block 514 containing two nodes represents inputs of a half 
adder (e.g., HA 420). The horizontal blocks 516 show the outputs of the full 
adders and the half adders in the previous level (or, reduction stage). The 
second matrix 520 is then reduced to a third matrix 530 by a second reduction 
step 525. The third matrix 530 is then reduced by third reduction step 535 to 
final matrix 540. <BR><BR>It should be noted that, as illustrated in FIG. 5, the 
first step of the reduction process 500 is to reduce the maximum number of nodes 
in each column of the input matrix 510 to 4, which is the closest element of the 
series 2, 3, 4, 6, 9, 13, 19, etc. The second step of the reduction process 500 
reduces the maximum number of nodes in each column of the second matrix 520 to 
3. Then, the third step of the reduction process 500 reduces the maximum number 
of nodes in each column of the third matrix 530 to 2. The reduction scheme 
proposed by Dadda effectively reduces the number of adder components required by 
the reduction tree. However, reduction trees generated using Dadda's techniques 
would have at least as many reduction stages as reduction trees generated using 
Wallace's techniques. Hence, the performance of Dadda reduction trees is not 
significantly better than that of Wallace reduction trees. <BR><BR>The present 
invention provides a tree reduction technique that further decreases in the 
number of stages (and hence adder components used) in parallel multipliers. 
According to one embodiment of the present invention, under certain 
circumstances, a even more economical (in terms of CSA stages) implementation of 
the reduction tree can be achieved. The present invention is particularly 
applicable to signed/unsigned multiplication involving one signed number and an 
unsigned number and signed multiplication involving two signed numbers. 
<BR><BR>FIG. 6 illustrates steps of the tree reduction process 600 according to 
one embodiment of the present invention. Steps of process 600 may be implemented 
within an EDA (electronic design automation) system as part of an HDL compile 
process. Steps of process 600 may also be implemented with computer executable 
codes or computer readable languages such as C++, VHDL, Verilog, etc., and 
contained within an HDL description of a muliplier. <BR><BR>As illustrated, the 
present embodiment receives an HDL description 605 that includes a description 
of a multiplier. According to one embodiment of the present invention, HDL 
description 605 describes the size of the operands, the operand types, etc. of 
the multiplier. In another embodiment of the present invention, HDL description 
605 may contain computer readable codes that define steps of the tree reduction 
process 600 in HDL (e.g., VHDL, Verilog, etc). <BR><BR>At step 610, the process 
600 of the present embodiment constructs an input matrix based on the operands 
of the multiplier. In the present embodiment, each node of the input matrix 
represents a partial product to be added by the multiplier. For instance, if a 
5-bit-by-5-bit unsigned multiplier is defined in the HDL description 605, then 
the process 600 will generate an input matrix that is similar to matrix 510. 
FIG. 7A illustrates, as another example, an input matrix 710 that is generated 
by step 610 for a 7-bit-by-4-bit signed multiplier if such a multiplier is 
described in the HDL description 605. An exemplary input matrix 1210 for a 
5-bit-by-3-bit signed multiplier is illustrated in FIG. 12A. Another exemplary 
input matrix 1220 for a 4-bit-by-4 bit signed multiplier is illustrated in FIG. 
12B. An exemplary input matrix 1230 for a 5-bit-signed-by-3-bit-unsigned 
multiplier is illustrated in FIG. 12C. Yet another exemplary input matrix 1240 
for a 5-bit-unsigned-by-3-bit-signed multiplier is illustrated in FIG. 12D. 
Methods for constructing an input matrix are well known in the art, and are 
therefore not described herein to avoid obscuring aspects of the invention. 
<BR><BR>At step 620, the process 600 of the present embodiment determines a 
depth K of the input matrix. The depth K of the input matrix is the maximum 
number of nodes per bit (or column) of the input matrix. For instance, for input 
matrix 710, the depth K would be 5 because the maximum number of nodes per 
column of the matrix 710 is 5. <BR><BR>At step 630, the process 600 of the 
present invention calculates all the maximum stage capacity numbers .delta. that 
are smaller than or equal to K. In the present embodiment, the maximum stage 
capacity numbers are elements of the series 2, 3, 4, 6, 9, 13, 19, 28, etc. The 
maximum stage capacity numbers may be calculated by the equation: 
<BR><BR>.delta..sub.i+1 =floor(.delta..sub.i *3/2), where floor (x) of a number 
x is the largest integer that is smaller than or equal to x. <BR><BR>An 
exemplary series of maximum stage capacity numbers and their corresponding stage 
numbers are illustrated below in Table 3. <BR><BR><PRE>             TABLE 3
            Stage (L)  Maximum Stage Capacity (.delta..sub.L)
                0                         2
                1                         3
                2                         4
                3                         6
                4                         9
                5                        13
                6                        19
                8                        42
                9                        63
               10                        94
               11                        141
               12                        211
</PRE><BR><BR>For example, the depth K for the input matrix 710 is 5. Hence, the 
process 600 of the present invention calculates all the maximum stage capacity 
numbers .delta. that are smaller than or equal to 5. Thus, in the present 
example, the process 600 generates the series 2, 3, and 4. <BR><BR>At step 640, 
the process 600 of the present embodiment performs a trial reduction by 
attempting to "jump" or "skip" a reduction stage by by-passing the stage that 
has a maximum stage capacity number immediately smaller than K. For example, the 
process 600 attempts to reduce the input matrix 710 such that the maximum stage 
capacity of the resulting matrix is 3. <BR><BR>A successful exemplary trial 
reduction step is illustrated in FIG. 7B. As illustrated, matrix 710 is marked 
with vertical blocks 712 and 714. Vertical blocks 712 with three inputs 
represent inputs of full adders (e.g., FA 410) and vertical blocks 714 with two 
inputs represent inputs of half adders (e.g., HA 420). An exemplary trial 
reduction matrix 720 is illustrated in FIG. 7B. Trial reduction matrix 720 is 
marked with horizontal blocks 722 which represent outputs of the full adders and 
half adders that reduces the matrix 710. <BR><BR>It should be noted that the 
trial reduction step 640 may fail for certain input matrix configurations. For 
instance, for matrix 510, it would be impossible to reduce the maximum number of 
nodes per column to 3 nodes after one reduction stage using only (3,2) counters 
and (2,2) counters. <BR><BR>At step 650, the process 600 determines whether the 
trial reduction step 640 is successful by determining whether the resulting 
matrix has more nodes than the maximum stage capacity of the target stage. If 
the resulting matrix has fewer than or the same number of nodes per bit as the 
maximum stage capacity of the target stage, the reduction process 600 of the 
present embodiment is capable of producing a reduction tree that has one fewer 
reduction level than conventional reduction trees. It is therefore possible to 
reduce the input matrix to the output matrix in (L-1) stages. However, if the 
resulting matrix has more nodes per bit than the maximum stage capacity of the 
target, the reduction process 600 will not be able to produce a reduction tree 
that has fewer reduction levels than conventional reduction trees. It is 
therefore only possible to reduce the input matrix to the final matrix in L 
stages. <BR><BR>At step 660, if it is determined that the trial reduction step 
640 succeeds in "skipping" a stage, the process 600 sets the initial reduction 
stage to the one that is lower than the stage that has a maximum stage capacity 
closest to and lower than K. In the present embodiment, the initial reduction 
stage would be stage (L-2). In the present embodiment, a variable "min _stage" 
(for indicating the minimum number of reduction stages required) would be set to 
(L-1). <BR><BR>At step 670, If it is determined that the trial reduction step 
640 fails in "skipping" a stage, the process 600 then sets the initial reduction 
stage to the one that has a maximum stage capacity lower than and closest to K. 
The initial reduction stage would be stage (L-1). In the present embodiment, the 
variable "min_stage" would be set to L. <BR><BR>At step 680, the process 600 of 
the present embodiment determines the maximum number of bits (or columns) that 
can be "squeezed" to a single node within the minimum number of reduction stages 
determined by step 650. The delay and area of the multiplier is determined by 
partial products generation logic, reduction tree logic and CPA logic. Reducing 
the delay and area of each of these logic circuits thus results in a reduction 
of delay and area of the multiplier. The area and delay of a CPA are the 
functions of bit width. An adder with shorter width has shorter delay and 
smaller area than wider adders. Thus, it is desirable to reduce the width of the 
CPA. In the present embodiment of the invention, step 680 reduces as many 
columns in the LSB of the reduction tree down to as most 1 bit such that the CPA 
has the shortest possible bit width. <BR><BR>Table 4 below illustrates 
pseudocode according to an implementation of step 680 of the present embodiment. 
<BR><BR><PRE>    TABLE 4
    /* Find out max_1_node_LSBs, maximum number of columns which
    can be reduced to 1 row within min_stage stages of reduction.
    Assume that the bit index of bits matrix starts from 0 - LSB
    */
        (1) Set max_1_node_LSBs = 0.
        (2) LOOP for squeeze_bit_idx from 0 to MSB of the matrix
        T
            (2.1) LOOP for reduction stage L from min_stage
            down to 1
                (2.1.1) For bit_x in [0, squeeze_bit_idx],
                assume there are n nodes in column bit_x
                    (2.1.1.1) If n&gt;2, then apply (n/3) full
                    adders
                    (2.1.1.2) If n = 2 AND all columns of
                    bits from 0 to bit_x have at most one
                    node, then apply one half adder in bit_x
                    to reduce the number of nodes down to one
                (2.1.2) For bit_x = squeeze_bit_idx+1, apply
                reduction process with target node number .delta..sub.L +
                1
                (2.1.3) For bit_x &gt; squeeze_bit_idx+1, apply
                reduction process with target node number .delta..sub.L
            (2.2) At the final reduction stage, check the
        number of nodes for each bit. If any column has more
        than 2 nodes (exception: bit squeeze_bit_idx+1 can have
        3 nodes), then exit LOOP of (2); Otherwise, set
        max_1_node_LSBs = (squeeze_bit_idx+1), continue LOOP of
        (2)
</PRE><BR><BR>As illustrated in Table 4, the step 680 determines 
"max_1_node_LBSs," which is the maximum number of columns reducible to a single 
node within the predetermined minimum number of reduction stages. <BR><BR>At 
step 690, the process 600 of the present invention performs an actual tree 
reduction step using the initial target stage determined at steps 660 or 670. 
The actual reduction step 690 of the present embodiment also uses the maximum 
number of "squeezed" columns (max_1_node_LSBs) determined at step 680. The step 
of performing the actual tree reduction in accordance with an embodiment of the 
present invention is described below in pseudocode in Table 5. <BR><BR><PRE>    TABLE 5
    /* Actual tree reduction */
        LOOP for reduction stage L from min_stage down to 1
            For bit_x in [0, max_1_node_LSBs-1], assume there
            are n nodes in column bit_x.
                If n&gt;2, then apply (n/3) full adders.
                If n=2 AND all columns of bits from 0 to bit_x
                have at most one node, then apply one half
                adder in bit_x to reduce number of nodes down
                to one.
        EXIT
</PRE><BR><BR>It should be noted that, in the present embodiment of the 
invention, the step of "squeezing" the columns (e.g., step 680) and the step of 
actual tree reduction (e.g., step 690) are performed separately. Purposes of 
separating these steps include (1) minimization of the width of the CPA and (2) 
minimization of the number of full adders and half adders used in the reduction 
tree. <BR><BR>FIG. 7C illustrates an exemplary actual tree reduction step (e.g., 
690) in accordance with the present embodiment. As illustrated, input matrix 710 
with depth K=5 is first reduced to matrix 730. It should be noted that matrix 
730 has at most 3 nodes in all columns except column 3, which has 4 nodes. 
Matrix 730 is then reduced again to matrix 740, which has at most 2 nodes in 
each column except column 3. It should be noted that, prior to the actual tree 
reduction step, the maximum number of columns squeezable to 1 bit, three columns 
(columns 0, 1 and 2) are "squeezed" such that they have at most one node such 
that the nodes can be provided directly to the output of the multiplier without 
going through the final adder. The third node 742 is for coupling to a carry-in 
input of a final adder. <BR><BR>The process 690 of the present embodiment will 
also generate a netlist 692 for the reduction tree. In the present example, the 
reduction tree reduces the matrix 710 into the final matrix 730 in two stages. 
<BR><BR>Thereafter, at step 694, other HDL compilation processes are carried out 
to generate a netlist 696 of a parallel multiplier. <BR><BR>It should be noted 
that, in one embodiment of the present invention, steps of the process 600 (e.g, 
steps 610 to 694) are defined by an HDL synthesizer of the EDA system. In that 
embodiment, HDL description 605 may only contain a description of the 
characteristics of the mutliplier (e.g., operand types, number of bits in the 
operands, etc.), and may not include implementation detail of the multiplier. In 
other embodiments of the present invention, HDL description 605 may contain 
computer readable codes for causing an EDA system to perform steps of the 
process 600 (e.g., steps 610 to 694). <BR><BR>A block diagram of an exemplary 
parallel multiplier 800 according to an embodiment of the present invention is 
illustrated in FIG. 8. As illustrated, multiplier 800 of the present embodiment 
includes a partial product generation block 810, a reduction tree structure 830 
and a carry propagate adder (CPA) 840. As illustrated, partial product 
generation block 810 receives operands A and B and outputs the partial products 
of the operands in the form of a matrix 820. Matrix 820 is then provided to 
reduction tree structure 830. In accordance with the present embodiment, 
reduction tree structure 830 includes one fewer reduction stages than 
conventional reduction trees. Particularly, the reduction tree structure 830 may 
be generated by process 600 and includes only two reduction stages. <BR><BR>With 
reference still to FIG. 8, the outputs of the reduction tree structure 830 is an 
output matrix 840. As shown, the output matrix 840 includes 3 rows: the first 
row includes eleven nodes from bit-0 to bit-10, the second row includes six 
nodes from bit-4 to bit-9, and the third row includes a single node at bit 4. 
Bit-0 to bit-3 are directly coupled to the output of the multiplier because 
these bits do not need to be added by CPA 850. Bit-4 to bit-10 are added by CPA 
850 to form the MSBs of the final product. It should also be noted that the 
single node 842 at bit-4 of the output matrix 840 is provided to the carry-input 
Ci of the CPA 850. CPA 850 adds the appropriate bits of the output matrix 840 to 
generate a product at output 860. <BR><BR>In accordance with the present 
embodiment, allowing bit-4 of the output matrix 840 to have three rows has two 
benefits. First, fewer number of counters are required in the reduction tree. 
Second, in certain cases, more columns in the output matrix can be "squeezed." 
FIG. 10A illustrates a reduction tree 1010 for a 5-bit-by-5-bit signed 
multiplier that does not have a column with three rows in the final stage. As 
illustrated, a total of twelve full adders and eight half adders are used in the 
tree 1010. FIG. 10B illustrates a reduction tree 1050 for the 5-bit-by-5-bit 
signed multiplier that has a column with three rows in the final (output) stage. 
Tree 1050 is constructed with twelve full adders but only three half adders. In 
comparison to tree 1010, tree 1050 utilizes five fewer adders. <BR><BR>FIG. 11A 
illustrates a reduction tree 1110 for a 4-bit-by-4-bit signed mutliplier that 
does not have a column with three rows in the final stage. As illustrated, only 
bit-0 can be "squeezed" to 1 node. FIG. 11B illustrates a reduction tree 1150 
for the 4-bit-by-4-bit signed multiplier that has a column with three nodes in 
the final (output) stage. As shown, columns 0, 1 and 2 are "squeezed" to a 
single node, thus reducing the width of the CPA. <BR><BR>According to another 
embodiment of the present invention, the run-time of the process of constructing 
a reduction tree can be improved under certain conditions. Particularly, when 
the maximum number of nodes per bit (column) of an input matrix is .delta..sub.L 
+1 (e.g., K=3, 4, 5, 7, 10, 14, etc.), then the minimum number of reduction 
stages needed can be easily determined. According to the present embodiment, 
when an extra node occurs on the "low edge" the input matrix, then it can be 
automatically determined that the input matrix can be reduced as if the extra 
node does not exist. When an extra node occurs on the "high edge" of the input 
matrix, and if .delta..sub.L is one of the series {4, 13, 19, 28, 94, 211 316, . 
. . }, then the extra node can also be treated as if it does not exist. In other 
words, the extra node on the "high edge" can be absorbed when .delta..sub.L-1 is 
odd, which is also equivalent to the condition that .delta..sub.L mod 3.noteq.0. 
<BR><BR>FIG. 9 illustrates an exemplary input matrix 900 that includes an extra 
"low edge" node 910 and an extra "high edge" node 920. When determining the 
minimum reduction stages required for reducing the input matrix 900, because 
node 910 occurs on the low edge and because node 920 occurs on the high edge and 
because .delta..sub.L is 4, both nodes 910 and 920 can be absorbed. Thus; input 
matrix 900 can be reduced in the same number of reduction stages as if the extra 
nodes 910 and 920 do not exist. Thus, whenever such extra high-edge nodes and 
low-edge nodes occur, run-time of tree reduction processes (e.g., process 600) 
can be significantly improved. <BR><BR>The present invention, fast parallel 
multipliers implemented using improved tree reduction methods, have thus been 
disclosed. The techniques and methods disclosed herein enable circuit designers 
to build reduction trees that have lower delay and consume lower die area than 
conventional reduction trees. Particularly, the techniques and methods disclosed 
herein enable the construction of reduction trees that have one fewer reduction 
stage than conventional reduction trees. Because the length the longest delay 
path of a reduction tree is mainly determined by the number of reduction stages 
and the delay of a full adder, the parallel multipliers disclosed herein have a 
smaller delay and can be operated at a higher speed. Additionally, the reduction 
tree of one embodiment of the present invention is constructed in such a way 
that as many bits in final stage have at most one node. In this way, the width 
of the final adder can be reduced, thus reducing the overall delay of the 
multiplier. <BR><BR>It should be appreciated that the present invention has been 
described with specific references. However, it should be appreciated that 
specific references within the present disclosure should not be construed to 
limit the scope of the present invention. Rather, the scope of the present 
invention should be construed according to the below claims. <BR><BR>
<CENTER><B>* * * * *</B></CENTER>
<HR>

<CENTER><!-- <A HREF=""><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A> --><A 
href="http://patimg1.uspto.gov/.piw?Docid=06490608&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO1%2526Sect2%3DHITOFF%2526d%3DPALL%2526p%3D1%2526u%3D%2Fnetahtml%2Fsrchnum.htm%2526r%3D1%2526f%3DG%2526l%3D50%2526s1%3D6490608.WKU.%2526OS%3DPN%2F6490608%2526RS%3DPN%2F6490608&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=086A6F8D0A8A"><IMG 
alt=[Image] src="United States Patent 6,490,608.files/image.gif" border=0 
valign="middle"></A> 
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6490608.WKU.%26OS%3DPN%2F6490608&amp;backLabel1=Back%20to%20Document%3A%206,490,608"><IMG 
      alt="[View Shopping Cart]" 
      src="United States Patent 6,490,608.files/cart.gif" border=0 
      valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,490,608&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO1%26Sect2%3DHITOFF%26d%3DPALL%26p%3D1%26u%3D%2Fnetahtml%2Fsrchnum.htm%26r%3D1%26f%3DG%26l%3D50%26s1%3D6490608.WKU.%26OS%3DPN%2F6490608&amp;backLabel1=Back%20to%20Document%3A%206,490,608"><IMG 
      alt="[Add to Shopping Cart]" 
      src="United States Patent 6,490,608.files/order.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=6490608.WKU.&amp;OS=PN/6490608&amp;RS=PN/6490608#top"><IMG 
      alt=[Top] src="United States Patent 6,490,608.files/top.gif" border=0 
      valign="middle"></A> </TD></TR></TBODY></TABLE><A name=bottom></A><A 
href="http://www.uspto.gov/patft/index.html"><IMG alt=[Home] 
src="United States Patent 6,490,608.files/home.gif" border=0 
valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
alt="[Boolean Search]" src="United States Patent 6,490,608.files/boolean.gif" 
border=0 valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG alt="[Manual Search]" 
src="United States Patent 6,490,608.files/manual.gif" border=0 
valign="middle"></A> <A href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG 
alt="[Number Search]" src="United States Patent 6,490,608.files/number.gif" 
border=0 valign="middle"></A> <A 
href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
src="United States Patent 6,490,608.files/help.gif" border=0 
valign="middle"></A> </CENTER></BODY></HTML>
